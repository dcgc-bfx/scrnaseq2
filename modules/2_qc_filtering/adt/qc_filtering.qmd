---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "qc_filtering_adt"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/2_qc_filtering/adt"
  
  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay. If null, will be set to the default assay of the input Seurat object.
  default_assay: "ADT"
  
  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. Computations will access only the relevant parts of the data. Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: true
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). Once done, matrix directories will be copied back to the module directory. The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: true
  
  # Which barcode QC should be shown. Can be any barcode metadata column.
  # Set to 'null' to deacivate.
  barcode_qc:
  - "nCount_ADT"
  - "nFeature_ADT"

  # Which pairs of barcode QC should be plotted in scatter plots. 
  # Separate QC by space character. Can only be numeric barcode metadata columns.
  # Set to 'null' to deacivate.
  barcode_qc_cor:
  - "nFeature_ADT nCount_ADT"
  - "nFeature_ADT pMito_ADT"

  # Filter for barcodes. Set to 'null' to deactivate.
  barcode_filter: !expr list(
    nCount_ADT = c(1000, NA),
    nFeature_ADT = c(400, 10000))

  # Filter for features. Set to 'null' to deactivate.
  feature_filter: !expr list(
    min_counts = 1,
    min_cells = 1)
    
  # File with list of cells to remove after initial QC. Set to 'null' to deactivate.
  cells_to_remove: null
    
  # List of samples to remove after initial QC. Set to 'null' to deactivate.
  samples_to_remove: null

  # Remove samples with too few cells
  samples_min_cells: 10
  
  # Number of cores to use for computations
  cores: 4
  
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# QC and filtering ADT

```{r}
#| label: setup

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "scrnaseq")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)

# Get module directory (needed to access files within the module directory)
module_dir = params$module_dir
```

```{r}
#| label: qc_filtering_adt_preparation

# CODE
# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")

# Be verbose or not
verbose = param("verbose")

# Parallelisation plan for all functions that support future
plan(multisession, workers=param("cores"))

# DIRECTORIES
# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# SEURAT OBJECT
# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatString("Could not find a sc.rds file in {prev_module_dir}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Check that the Seurat object is okay
if (length(SeuratObject::Layers(sc)) == 0) {
  stop("No layers found in Seurat object. Please check the input object.")
}

# Set default assay standard
default_assay = param("default_assay")
if (is.null(default_assay)) default_assay = Seurat::DefaultAssay(sc)
Seurat::DefaultAssay(sc) = default_assay

# ON-DISK LAYERS (if used)
on_disk_counts = param("on_disk_counts")

# If requested, move on-disk layers to faster temp location for faster access
on_disk_use_tmp = param("on_disk_use_tmp")
if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
}
```

The steps below represent a standard pre-processing workflow for single-cell data, including quality control, the respective filtering of barcodes and features, data normalization and scaling, and the detection of highly variable features.

::: {.callout-tip title="Why is pre-processing so important? (example scRNA-seq)" collapse="true"}
Cells and antibody tags are prone to technical artifactsâ€”damaged cells yield low signal, whereas free antibodies and aggregates inflate background. Rigorous QC and filtering remove these confounders. Normalization corrects for differences in total ADT depth across cells, while scaling harmonizes feature distributions. Finally, focusing on highly variable protein features enhances downstream clustering and interpretation.
:::

## Quality control

```{r}
#| label: qc_filtering_adt_qc_barcodes_features

# Calculate QC for barcodes (cells, nuclei or spots)
# Calculate QC for features (genes, peaks, proteins)

# BARCODES
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]
orig_idents = levels(sc$orig.ident)

# FEATURES
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)
# Calculate number of barcodes above threshold for each layer (dataset)
for (l in SeuratObject::Layers(sc, "^counts")) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get data for layer (sample) and count
  counts = sc[[default_assay]][l]
  if (!is.null(feature_filter) & 
      n %in% names(feature_filter) &
      "min_counts" %in% names(feature_filter[[n]])) {
    num_bcs_expr = rowSums(counts >= feature_filter[[n]]$min_counts)
  } else {
    num_bcs_expr = rowSums(counts >= 1)
  }
  
  # Add to metadata
  sc[[default_assay]][[paste("nBcsThreshold", n, sep="_")]] = num_bcs_expr
}
```

We start the analysis by removing unwanted barcodes from the dataset(s). Three commonly used QC metrics include:

-   the number of unique features detected in each cell ("nFeature_ADT")
-   the total number of molecules detected in each cell ("nCount_ADT"), and

::: {.callout-tip title="Which barcodes can be considered to be of low quality?" collapse="true"}
On the one hand, low-quality cells such as dying, degraded and damaged cells, and empty droplets will often result in few proteins ("nFeature_ADT") and low total counts ("nCount_ADT"). On the other hand, cell doublets may show an aberrantly high number of proteins. Since the total number of reads detected within a barcode typically strongly correlates with the number of unique features, we can focus on the number of unique features for filtering.
:::

::: {.callout-tip title="Impact of low-quality barcodes on downstream analyses" collapse="true"}
First of all, low-quality barcodes of different cell types might cluster together due to similarities in their damage-induced protein expression profiles. This leads to artificial intermediate states or trajectories between sub-populations that would otherwise be distinct. Second, low-quality barcodes might mask relevant protein expression changes. The main differences captured by the first principal components will likely be based on barcode quality rather than the underlying biology, reducing the power of dimensionality reduction. Likewise, highly variable features might just be features that differ between low- and high-quality barcodes. Lastly and equally important, the low number of total counts in low-quality barcodes might lead to artificial upregulation of features due to wrong scaling effects during the normalisation process.
:::

```{r}
#| label: qc_filtering_adt_qc_plots
#| results: asis

# Plot QC measures for barcodes (cells, nuclei or spots)

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
f = barcode_qc %in% colnames(sc[[]])
if (!all(f)) {
  CalloutBox(x="Cannot find QC {barcode_qc[!f]*} in barcode metadata.", type="warning")
  barcode_qc = barcode_qc[f]
}

# Do not plot QC if there are no features to plot
if (length(barcode_qc) > 0) {
  # Make plots
  plist = PlotBarcodeQC(sc, qc=barcode_qc, filter=barcode_filter, log10="nCount")
  
  # Prepare captions
  captions = GeneratePlotCaptions(names(plist), assay_names=SeuratObject::Assays(sc))

  # Set up layout and generate chunks
  chunk_template = "
##### {{type}}

\`\`\`{r}
#| label: fig-qc_filtering_rna_qc_{{type}}
#| fig-cap: {{caption}}
#| echo: false
#| message: false
#| warning: false

plist[[{{i}}]]
\`\`\`
"
  
  cat("::: panel-tabset", sep="\n")
  
  for (i in seq(plist)) {
    chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption=captions[i])
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, sep='\n')
    }
  }
  
  cat(":::\n")
} else {
  CalloutBox(x="No barcode QC parameters for plotting available.", type="note")
}
```

```{r}
#| label: qc_filtering_adt_spatial_qc_plots
#| eval: !expr length(SeuratObject::Images(sc)) > 0
#| include: !expr length(SeuratObject::Images(sc)) > 0
#| results: asis

# Plot QC measures for barcodes (cells, nuclei or spots) in spatial context

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
f = barcode_qc %in% colnames(sc[[]])
if (!all(f)) {
    CalloutBox(x="Cannot find QC {barcode_qc[!f]*} in barcode metadata.", type="warning")
    barcode_qc = barcode_qc[f]
}

# Do not plot QC if there is no spatial information
if (length(SeuratObject::Images(sc)) > 0) {
    
    # Do not plot QC if there is no QC metric available
    if (length(barcode_qc) > 0) {
        
        # For each QC metric
        cat("::: panel-tabset\n\n")
        for(q in barcode_qc) {
            cat ("#####", q, "\n\n")
            
            # Make spatial plots split by sample
            plist = FeaturePlotSpatial(sc, features=q, combine=FALSE)  %>% purrr::flatten()
            plist = purrr::map(plist, function(p) {
                p =  p + theme(legend.title=element_blank())
                p = p + viridis::scale_fill_viridis(trans=ifelse(grepl(pattern="nCount", q), "log10", "identity"))
                return(p)
            })
            
            # Make captions
            orig_idents = SeuratObject::Images(sc) %>% gsub("^(fov|image)\\.", "", .)
            captions = GeneratePlotCaptions(q, assay_names=SeuratObject::Assays(sc)) %>% paste("for dataset {orig_idents}") %>% FormatString()
            
            # Make chunk template for spatial plots
            chunk_template = "
\`\`\`{r}
#| label: fig-qc_filtering_rna_spatial_qc_{{qc}}_dataset_{{dataset}}
#| fig-cap: {{caption}}
#| dev: png

plist[[{{i}}]]
\`\`\`
"
            # Fill out and print spatial plots
            cat("::: panel-tabset\n\n")
            for(i in seq_along(plist)) {
                cat ("##### ", orig_idents[i], "\n\n")
                chunk_filled =  knitr::knit_expand(text=chunk_template, qc=q, i=i, dataset=orig_idents[i], caption=captions[i])
                if(interactive()) {
                    print(EvalKnitrChunk(chunk_filled))
                } else {
                    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
                    cat(chunk_filled, '\n')
                }
            }
            cat(":::\n\n")
        }
        cat(":::\n\n")
    } else {
        CalloutBox(x="No barcode QC parameters for plotting available.", type="note")
    }
}
```

```{r}
#| label: qc_filtering_adt_qc_cor_plots
#| results: asis

# Plot QC correlation plots for barcodes (cells, nuclei or spots)

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Find barcode QC columns
barcode_qc_cor = strsplit(param("barcode_qc_cor"), "\\s+")

missing_barcode_qc = purrr::map(barcode_qc_cor, function(b) {
  f = b %in% colnames(barcode_metadata)
  return(barcode_qc[!f])
}) %>% unlist %>% unique()
if (length(missing_barcode_qc) > 0) CalloutBox(x="Cannot find QC {missing_barcode_qc*} in barcode metadata.", type="warning")

f = purrr::map_lgl(barcode_qc_cor, function(b) return(all(!b %in% missing_barcode_qc)))
barcode_qc_cor = barcode_qc_cor[f]

# Do not plot QC if there are no features to plot
if (length(barcode_qc_cor) > 0) {
  # Make plots
  plist = PlotBarcodeQCCor(sc, qc=barcode_qc_cor, filter=barcode_filter)

  # Prepare captions
  captions = GeneratePlotCaptions(names(plist), assay_names=SeuratObject::Assays(sc), split="__")

  # Generate chunks
  chunk_template = "
##### {{i}}

\`\`\`{r}
#| label: fig-qc_filtering_rna_qc_{{type1}}_vs_{{type2}}
#| fig-cap: {{caption}}
#| echo: false
#| message: false
#| warning: false

plist[[{{i}}]]
\`\`\`
"

  cat("::: panel-tabset", sep="\n")
  
  for (i in seq(plist)) {
    chunk_filled =  knitr::knit_expand(text=chunk_template, type1=barcode_qc_cor[[i]][1], type2=barcode_qc_cor[[i]][2], i=i, caption=captions[i])
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, sep='\n')
    }
  }
  
  cat(":::", sep="\n")
} else {
  CalloutBox(x="No barcode QC parameters for correlation plots available.", type="note")
}
```

## Features with highest expression

We next investigate whether there are individual features that are represented by an unusually high number of counts. For each barcode, we first calculate the percentage of counts per feature. Subsequently, for each feature, we calculate the median value of these percentages in all barcodes. Proteins with the highest median percentage of counts are plotted below.

```{r}
#| label: qc_filtering_adt_highest_proteins

# Calculate highest expressed genes

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

###########
# Overall #
###########

# Get top 20 proteins overall
highestExpr = purrr::map_dfr(SeuratObject::Layers(sc, "^counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  highest = feature_metadata[idx, ] %>% 
    tibble::rownames_to_column("gene") %>%
    dplyr::select(median=dplyr::all_of(m), gene)
  highest$orig.ident = n
  return(highest)
})
highestExpr$orig.ident = factor(highestExpr$orig.ident, levels=orig_idents)

# Now rank genes by overall expression
top_genes = highestExpr %>% dplyr::arrange(-median) %>% dplyr::pull(gene) %>% unique()
highestExpr$rank = match(highestExpr$gene, top_genes)
highestExpr$gene = factor(highestExpr$gene, levels=top_genes)

# Collect summary statistics for top 20 genes for each layer (dataset)
highestExpr_summary = purrr::map_dfr(SeuratObject::Layers(sc, "^counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  
  # Get percentages for top 20 genes
  top_counts = sc[[default_assay]][l][idx, ]
  bcs = top_counts %>% colnames()
  total_counts = barcode_metadata[bcs, paste0("nCount_", default_assay), drop=TRUE]
  top_perc = Matrix::t(Matrix::t(top_counts)/total_counts)*100
  
  # Now calculate summary statistics (min, q25, median, mean, q75, max) per feature
  with_progress({
    top_perc_summary = CalculateBoxplotStats(top_perc, margin=1, chunk_size=NULL)
  }, enable=verbose)
  top_perc_summary$gene = rownames(top_perc_summary)
  rownames(top_perc_summary) = NULL
  top_perc_summary$orig.ident = gsub(x=l, pattern="^counts\\.", replacement="")
  return(top_perc_summary)
})
highestExpr_summary$orig.ident = factor(highestExpr_summary$orig.ident, levels=orig_idents)
```

```{r}
#| label: fig-qc_filtering_adt_highest_proteins
#| fig-cap: "Highest expressed features overall"
#| warning: false

# Plot highest expressed genes (overall)

p = ggplot(highestExpr %>% dplyr::filter(rank<=10), aes(x=orig.ident, y=median, col=gene, group=gene)) + 
  geom_point() + 
  AddPlotStyle(title="Highest expression", 
           xlab="Sample", ylab="Median % of raw counts\n per protein", 
           legend_position="bottom") +
  scale_color_manual(values=rev(Seurat::DiscretePalette(n=10, "stepped")))
if (length(orig_idents) > 1) p = p + geom_line()
p
```

```{r}
#| label: qc_filtering_adt_highest_proteins_datasets
#| results: asis

# Plot highest expressed genes (per sample)

orig_idents = levels(sc$orig.ident)

# Make plots
plist = purrr::map(orig_idents, function(s) {
  # Subset data
  plot_data = highestExpr_summary %>% 
    dplyr::filter(orig.ident==s) %>%
    dplyr::arrange(-q50) %>%
    head(20) %>%
    dplyr::arrange(q50)
  plot_data$gene = factor(plot_data$gene, levels=unique(plot_data$gene))

  # Plot
  p = ggplot(plot_data, aes(x=gene, fill=gene)) +
    geom_boxplot(aes(ymin=lower_whisker, lower=q25, middle=q50, upper=q75, ymax=upper_whisker), stat="identity", width=1) +
    scale_x_discrete() +
    scale_y_continuous("% of total counts") +
    scale_fill_manual(values=rev(Seurat::DiscretePalette(n=20, "stepped"))) +
    AddPlotStyle() +
    theme(axis.title.y=element_blank(),legend.position="none") +
    coord_flip()
  
  return(p)
})
names(plist) = orig_idents

# Set up layout and generate chunks

chunk_template = "
##### {{dataset}}

\`\`\`{r}
#| label: fig-qc_filtering_rna_highest_genes_dataset_{{dataset}}
#| fig-cap: Highest expressed features for dataset '{{dataset}}'
#| echo: false
#| message: false
#| warning: false

plist[[{{i}}]]
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, dataset=orig_idents[i], i=i)
  if(interactive()) {
    print(EvalKnitrChunk(chunk_filled))
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

## Filtering

Cells and proteins are filtered based on the following thresholds:

```{r}
#| label: qc_filtering_adt_filters
#| results: asis

# Prepare filter tables for barcodes (cells, nuclei or spots) and features (genes, peaks, proteins)

orig_idents = levels(sc$orig.ident)

# BARCODES
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)
barcode_filter_tbl = purrr::map_dfr(names(barcode_filter), function(s) {
  tbl = purrr::map(barcode_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
        r = dplyr::case_when(
            is.na(f[1]) & is.na(f[2]) ~ "none",
            is.na(f[1]) & !is.na(f[2]) ~ paste0("<=", f[2]),
            !is.na(f[1]) & is.na(f[2]) ~ paste0(">=", f[1]),
            !is.na(f[1]) & !is.na(f[2]) ~ paste0(f[1], "-", f[2])
        )
        return(r)
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Range=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

# FEATURES
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)
feature_filter_tbl = purrr::map_dfr(names(feature_filter), function(s) {
  tbl = purrr::map(feature_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
        r = dplyr::case_when(
            is.na(f[1]) & is.na(f[2]) ~ "",
            is.na(f[1]) & !is.na(f[2]) ~ paste0("<=", f[2]),
            !is.na(f[1]) & is.na(f[2]) ~ paste0(">=", f[1]),
            !is.na(f[1]) & !is.na(f[2]) ~ paste0(f[1], "-", f[2]),
        )
        return(r)
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Value=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

# Provide info if no filtering is applied
if (length(barcode_filter) == 0) {
  CalloutBox(x="No barcode filtering was specified. All barcodes will be kept.", type="note")
}

if (length(feature_filter) == 0) {
  CalloutBox(x="No feature filtering was specified. All features will be kept.", type="note")
}
```

::: {layout-ncol="2"}
```{r}
#| label: tbl-qc_filtering_adt_feature_print_barcode_filters
#| echo: false
#| tbl-cap: !expr paste("Filters applied to barcodes for assay", default_assay)
#| eval: !expr length(barcode_filter) > 0
#| include: !expr length(barcode_filter) > 0

# Print barcode filters (cells, nuclei or spots)
gt(barcode_filter_tbl)
```

```{r}
#| label: tbl-qc_filtering_adt_feature_print_feature_filters
#| echo: false
#| tbl-cap: !expr paste("Filters applied to features for assay", default_assay)
#| eval: !expr length(feature_filter) > 0
#| include: !expr length(feature_filter) > 0

# Print feature filters (genes, peaks, proteins)
gt(feature_filter_tbl)
```
:::

The number of excluded cells and features is as follows.

```{r}
#| label: tbl-qc_filtering_adt_filter_barcodes
#| tbl-cap: !expr paste("Summary of excluded barcodes for assay", default_assay)

# Filter barcodes (cells, nuclei or spots)

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Apply filters to barcodes and record
barcodes_to_exclude = purrr::map(orig_idents, function(s) {
  # Apply user filters
  filter_result = purrr::map(names(barcode_filter[[s]]), function(n) {
    filter = barcode_filter[[s]][[n]]
    if (is.numeric(filter) & length(filter)==2) {
      if (is.na(filter[1])) filter[1] = -Inf
      if (is.na(filter[2])) filter[2] = Inf
      idx_exclude = which(barcode_metadata[["orig.ident"]] == s & !(barcode_metadata[[n]] >= filter[1] & barcode_metadata[[n]] <= filter[2]))
    } else {
      idx_exclude = which(barcode_metadata[["orig.ident"]] == s & !barcode_metadata[[n]] %in% filter)
    }
    return(rownames(barcode_metadata)[idx_exclude])
  })
  names(filter_result) = names(barcode_filter[[s]])
  
  # Cells to drop
  cells_to_remove = param("cells_to_remove")
  if (!is.null(cells_to_remove)) {
    cells_to_remove = readLines(cells_to_remove)
    idx_exclude = which(rownames(barcode_metadata) %in% cells_to_remove)
    filter_result[["cells_to_remove"]] = rownames(barcode_metadata)[idx_exclude]
  } else {
    filter_result[["cells_to_remove"]] = as.character(c())
  }
  
  # Samples to drop
  samples_to_remove = param("samples_to_remove")
  if (s %in% samples_to_remove) {
    idx_exclude = which(barcode_metadata[["orig.ident"]] == s)
    filter_result[["samples_to_remove"]] = rownames(barcode_metadata)[idx_exclude]
  } else {
    filter_result[["samples_to_remove"]] = as.character(c())
  }
  
  # Minimum number of cells for a sample to keep
  samples_min_cells = param("samples_min_cells")
  filter_result[["samples_min_cells"]] = as.character(c())
  if (!is.null(samples_min_cells)) {
    idx_exclude = which(barcode_metadata[["orig.ident"]] == s)
    if (length(idx_exclude) < samples_min_cells) {
      filter_result[["samples_min_cells"]] = rownames(barcode_metadata)[idx_exclude]
    }
  }
  
  return(filter_result)
})
names(barcodes_to_exclude) = orig_idents

# Summarise
barcodes_to_exclude_tbl = purrr::map_dfr(barcodes_to_exclude, function(s) {
  return(as.data.frame(purrr::map(s, length))) 
  })
rownames(barcodes_to_exclude_tbl) = names(barcodes_to_exclude)
barcodes_to_exclude_tbl$N = purrr::map_int(orig_idents, function(s) return(sum(barcode_metadata$orig.ident == s)))
barcodes_to_exclude_tbl$Excluded = purrr::map_int(barcodes_to_exclude, function(s) { return(purrr::flatten(s) %>% unique() %>% length())})
barcodes_to_exclude_tbl$PercKept = round((barcodes_to_exclude_tbl$N - barcodes_to_exclude_tbl$Excluded) / barcodes_to_exclude_tbl$N * 100, 2)
barcodes_to_exclude_tbl = barcodes_to_exclude_tbl %>% dplyr::relocate(N)

# Filter
barcodes_to_exclude = purrr::flatten(barcodes_to_exclude) %>% purrr::flatten_chr() %>% unique()
barcodes_to_keep = rownames(barcode_metadata)
barcodes_to_keep = barcodes_to_keep[!barcodes_to_keep %in% barcodes_to_exclude]
sc = subset(sc, cells=barcodes_to_keep)

gt(barcodes_to_exclude_tbl, rownames_to_stub=TRUE) %>%
    tab_spanner("Original", columns = c(N)) %>%
    tab_spanner("Filtered by", columns = c(-N, -Excluded, -PercKept)) %>%
    tab_spanner("Total", columns = c(Excluded, PercKept))

# Update orig.ident
levels_to_drop = table(sc$orig.ident)
levels_to_drop = names(levels_to_drop)[levels_to_drop==0]
sc$orig.ident = factor(sc$orig.ident, levels=setdiff(levels(sc$orig.ident), levels_to_drop))
```

```{r}
#| label: tbl-qc_filtering_adt_filter_features
#| tbl-cap: !expr paste("Summary of excluded features for assay", default_assay)

# Filter features (genes, peaks, proteins)

orig_idents = levels(sc$orig.ident)
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

# Iterate over samples and record a feature if it does not pass the filter
features_to_exclude = purrr::map(orig_idents, function(s) {
  l = paste("counts", s, sep=".")
  
  # Get features from layer (dataset)
  features = rownames(sc[[default_assay]][l])
  metadata = feature_metadata[rownames(feature_metadata) %in% features, ]
  
  # Filter
  if (!is.null(feature_filter) & 
      s %in% names(feature_filter) &
      "min_counts" %in% names(feature_filter[[s]])) {
    exclude = metadata[[paste("nBcsThreshold", s, sep="_")]] < feature_filter[[s]][["min_cells"]] # before: counts
  } else {
    exclude = rep(FALSE, nrow(metadata))
  }
  names(exclude) = rownames(metadata)
  return(exclude)
})
names(features_to_exclude) = orig_idents

# Find features that fail in all samples (get the ones that fail and then apply intersect iteratively)
features_to_exclude_all = purrr::map(features_to_exclude, function(x) return(names(x[x==TRUE]))) %>%
  purrr::reduce(intersect)

# Summarise
features_to_exclude_tbl = purrr::map_dfr(names(features_to_exclude), function(n) {
  # Boolean vector for all features in dataset
  features = features_to_exclude[[n]]
  df = data.frame(N=length(features), Fail=sum(features))
  
  df$FailAll = length(features_to_exclude_all)
  df$Kept = length(setdiff(names(features), features_to_exclude_all))
  df$PercKept = round(df$Kept / df$N * 100, 2)
  return(df)
})
rownames(features_to_exclude_tbl) = names(features_to_exclude)

# Remove features
features_to_keep = rownames(sc[[default_assay]])
features_to_keep = features_to_keep[!features_to_keep %in% features_to_exclude_all]
sc[[default_assay]] = suppressWarnings(subset(sc[[default_assay]], features=features_to_keep))

# Feature metadata is not subset correctly
sc[[default_assay]]@meta.data = feature_metadata[features_to_keep, ]
                             
# Print table
gt(features_to_exclude_tbl, rownames_to_stub=TRUE) %>%
    tab_spanner("Original", columns = c(N)) %>%
    tab_spanner("Filtered by", columns = c(-N, -FailAll, -Kept, -PercKept)) %>%
    tab_spanner("Total", columns = c(FailAll, Kept, PercKept))
```

After filtering, the size of the Seurat object is:

```{r qc_filtering_rna_filter_size}
sc
```

## Quality control post filtering

The updated QC plots are:

```{r}
#| label: qc_filtering_adt_postqc_plots
#| results: asis

# Plot QC measures for barcodes (cells, nuclei or spots) post filtering

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
f = barcode_qc %in% colnames(sc[[]])
if (!all(f)) {
  CalloutBox(x="Cannot find QC {barcode_qc[!f]*} in barcode metadata.", type="warning")
  barcode_qc = barcode_qc[f]
}

# Do not plot QC if there are no features to plot
if (length(barcode_qc) > 0) {
  # Make plots
  plist = PlotBarcodeQC(sc, qc=barcode_qc, filter=barcode_filter, log10="nCount")
  
  # Prepare captions
  captions = GeneratePlotCaptions(names(plist), assay_names=SeuratObject::Assays(sc))
  captions = paste(captions, "(filtered)")
  
  # Setup layout and generate chunks
  chunk_template = "
##### {{type}}

\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_{{type}}
#| fig-cap: {{caption}}
#| echo: false
#| warning: false
#| message: false

plist[[{{i}}]]
\`\`\`
"
  
  cat("::: panel-tabset\n")
  
  for (i in seq(plist)) {
    chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption=captions[i])
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, sep='\n')
    }
  }
  
  cat(":::\n")
} else {
  CalloutBox(x="No barcode QC parameters for plotting available.", type="note")
}
```

```{r}
#| label: qc_filtering_adt_postqc_cor_plots
#| results: asis

# Plot QC correlation plots for barcodes (cells, nuclei or spots) post filtering

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents, barcode_metadata)

# Find barcode QC columns
barcode_qc_cor = strsplit(param("barcode_qc_cor"), "\\s+")

missing_barcode_qc = purrr::map(barcode_qc_cor, function(b) {
  f = b %in% colnames(barcode_metadata)
  return(barcode_qc[!f])
}) %>% unlist %>% unique()
if (length(missing_barcode_qc) > 0) CalloutBox(x=FormatString("Cannot find QC {missing_barcode_qc*} in barcode metadata.", type="warning"))

f = purrr::map_lgl(barcode_qc_cor, function(b) return(all(!b %in% missing_barcode_qc)))
barcode_qc_cor = barcode_qc_cor[f]

# Do not plot QC if there are no features to plot
if (length(barcode_qc_cor) > 0) {

  # Make plots
  plist = PlotBarcodeQCCor(sc, qc=barcode_qc_cor, filter=barcode_filter)
  
  # Prepare captions
  captions = GeneratePlotCaptions(names(plist), assay_names=SeuratObject::Assays(sc), split="__")
  
  # Generate chunks
  chunk_template = "
##### {{i}}

\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_{{type1}}_vs_{{type2}}
#| fig-cap: {{caption}}
#| echo: false
#| message: false
#| warning: false

plist[[{{i}}]]
\`\`\`
"
  
  cat("::: panel-tabset\n")
  
  for (i in seq(plist)) {
    chunk_filled =  knitr::knit_expand(text=chunk_template, type1=barcode_qc_cor[[i]][1], type2=barcode_qc_cor[[i]][2], i=i, caption=captions[i])
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, sep='\n')
    }
  }
  
  cat(":::\n")
}  else {
  CalloutBox(x="No barcode QC parameters for correlation plots available.", type="note")
}
```

## Software

```{r}
#| label: qc_filtering_adt_save_software

sessioninfo = ScrnaseqSessionInfo(getwd()) %>% as.data.frame()
gt(sessioninfo)
```

## Parameter

```{r}
#| label: read_data_save_parameter

paraminfo = ScrnaseqParamsInfo(param()) %>% as.data.frame()
gt(paraminfo)
```

```{r}
#| label: qc_filtering_adt_save_seurat

# Dump the layers with the normalized data
layers = SeuratObject::Layers(sc, search="^data")
for(i in seq_along(layers)) {
  SeuratObject::LayerData(sc[[default_assay]], layer=layers[i]) = NULL
}

# Save Seurat object and layer data
# Note: counts and normalized data have been changed in this module, copying needed
outdir = file.path(module_dir, "sc")
with_progress({
  SaveSeuratRdsWrapper(sc,
                       outdir=outdir,
                       write_disk_data=on_disk_counts,
                       relative_paths=FALSE,
                       compress=FALSE
                       )
}, enable=verbose)
```

```{r}
#| label: qc_filtering_adt_finish

# Stop multisession workers
plan(sequential)
```
