---
# Module-specific parameters (that are not already in the profile yaml)
# Defaults
params:
  # Name of the module used in configurations
  module: "deg_analysis"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/10_deg_analysis"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  # NOTE: Change to null if all modules are implemented and sc objects are written
  prev_module_dir: null
  
  # Default assay
  default_assay: null

  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. 
  # Computations will access only the relevant parts of the data. 
  # Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: false
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. 
  # This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). 
  # Once done, matrix directories will be copied back to the module directory. 
  # The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: false
  
  # Number of cores to use for computations
  cores: 4
  
  # Contrasts to find differentially expressed genes
  # Add entries below 'value'.
  # Each entry has a unique name and the following keys:
  #
  #  condition_column: Categorial column in the barcode metadata (required)
  #  condition_group1: Condition levels in group 1 (required)
  #                    Use 'level1+level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #  condition_group2: Condition levels in group 2 (required)
  #                    Use 'level1,level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #
  # subset_column: Categorial column in the barcode metadata to subset for tests (default: null)
  #                For example, use 'orig.ident' for sample and 'seurat_clusters' for cluster (default: null)
  # subset_group: Levels to subset
  #               Use 'level1+level2' to use multiple levels for one subset
  #               Use 'level1+level2,level3' to do multiple subsets for testing
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #
  # bulk_by: Generate bulk samples by aggregating barcodes by one or more columns (e.g. 'individual' or 'individual+genotype') (default: null). Control the number of barcodes per bulk sample with downsample_n.
  # pseudobulk_samples: Generate this number of pseudo-bulk samples (default: null). Control the number of barcodes per pseudo-bulk sample with downsample_n.
  #
  # assay: Seurat assay, dimensionality reduction or barcode metadata columns ('column1,column2') to test on (default: 'RNA')
  # layer: In case of Seurat assay, which layer/slot to use (default: 'data'). Should be set specific for the test.
  # padj: Maximum adjusted p-value (default: 0.05)
  # log2FC: Minimum absolute log2 fold change (default: 0)
  # min_pct: Minimum percentage of barcodes expressing a feature in one group (default: 0.05)
  # test: Type of test. Can be 'wilcox', 'bimod', 'roc', 't', 'negbinom', 'poisson', 'LR', 'MAST', 'DESeq2' (default: 'wilcox').
  # downsample_barcodes: Downsample each group to at most n barcodes (default: null)
  # covariate: One or two columns (comma-separated) to include as covariates (default: null)
  #
  contrasts:
      value:
          - Comparison1:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
          - Comparison2:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
                bulk_by: "seurat_clusters"
          - Comparison3:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
                subset_column: "seurat_clusters"
                subset_group: "1,2,3+4"
    
  # Excel or csv file with contrasts
  contrasts_file: null
  
  # Run DEG tests: True, false or a list with contrast names
  run_deg_tests:
      - Comparison1
      - Comparison3
  
  # Run over-representation analysis (ORA) for DEG results: True, false or a list with contrast names
  run_deg_ora: true
    
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# DEG Analysis

```{r}
#| label: setup

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "scrnaseq")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)
library(patchwork)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir
```

```{r}
#| label: deg_analysis_preparation

# CODE
# Working directory is automatically back to scrnaseq2 at this point
# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")
source("R/functions_degs.R")

# Be verbose or not
verbose = param("verbose")

# Parallelisation plan for all functions that support future
plan(multisession, workers=param("cores"))

# DIRECTORIES
# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# SEURAT OBJECT
# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatString("Could not find a sc.rds file in {prev_module_dir}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
} else {
  on_disk_path = file.path(module_dir, "sc")
}

# Set default assay standard
default_assay = param("default_assay")
if (is.null(default_assay)) default_assay = Seurat::DefaultAssay(sc)
Seurat::DefaultAssay(sc) = default_assay
```

```{r}
#| label: deg_analysis_setup
#| 
# Parse the contrasts information
if (is.character(param("constrasts")) && file.exists(param("contrasts"))) {
  # Read from file
  contrasts_file = param("contrasts")
  
  # Sheet number appended?
  sheet = 1
  if (grepl(":\\d+$", deg_contrasts_file)) {
    sheet = gsub(pattern=".+:(\\d+)$", replacement="\\1", x=contrasts_file) %>% as.integer()
    contrasts_file = gsub(pattern=":\\d+$", replacement="", x=contrasts_file)
  }
  
  # Read Excel file and split into list, remove NA entries
  contrasts_list = readxl::read_excel(contrasts_file, sheet=1, col_names=TRUE)
  contrasts_list = split(contrasts_list, seq(nrow(contrasts)))
  
  contrasts_list = purrr::map(contrasts_list, function(contrast) {
      is_na = is.na(contrast)
      if (sum(is_na) > 0) contrast[[is_na]] = NULL
      return(contrast)
  })

} else {
  contrasts_list = param("contrasts")
    
  # Read from yaml parameter and prepare list
  contrasts_list = purrr::map(seq(contrasts_list), function(i) {
      contrast = contrasts_list[[i]][[1]]
      contrast$name = names(contrasts_list[[i]])
      return(contrast)
  })
}

# For each comparison, collect the necessary information (which groups to compare, the assay to use, etc).
# Each list entry is a comparison. If a comparison is done for multiple subsets (subset_column/subset_group), each subset is a separate entry.
contrasts_list = NewContrastsList(sc, contrasts_list)

# For each comparison, prepare an individual Seurat object with counts and data. Bulk-aggregate if requested. Downsample if requested.
contrasts_list = PrepareContrastsListObjects(sc, contrasts_list)

# Which contrasts should be DEG tested?
run_deg_tests = param("run_deg_tests")
deg_tests_idx = c()
if (is.logical(run_deg_tests) && run_deg_tests) {
    # if TRUE all, else none
    if (run_deg_tests) {
        deg_tests_idx = seq(contrasts_list)
    } else {
        deg_tests_idx = c()
    }
} else if (is.character(run_deg_tests)) {
    # if character, only those
    deg_tests_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_deg_tests))
}
have_deg_comparisons = length(deg_tests_idx) > 0

# For the contrasts that are DEG tested: for which should also over-representation analysis be run?
run_deg_ora = param("run_deg_ora")
deg_ora_idx = c()
if (is.logical(run_deg_ora)) {
    # if TRUE all, else none
    if (run_deg_ora) {
        deg_ora_idx = deg_tests_idx
    } else {
        deg_ora_idx = c()
    }
} else if (is.character(run_deg_ora)) {
    # if character, only those
    deg_ora_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_deg_ora))
}
if (!all(deg_ora_idx %in% deg_tests_idx)) {
  stop("Not all contrasts for over-representation analysis are also tested for DEGs.")
}
have_ora = length(deg_ora_idx) > 0

# Which contrasts should be analysed with GSEA?
run_gsea = param("run_gsea")
gsea_idx = c()
if (is.logical(run_gsea)) {
    # if TRUE all, else none
    if (run_gsea) {
        gsea_idx = seq(contrasts_list)
    } else {
        gsea_idx = c()
    }
} else if (is.character(run_gsea)) {
    # if character, only those
    gsea_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_gsea))
}
have_gsea_comparisons = length(gsea_idx) > 0
```

## DEG Analysis

If requested, we identify genes that are differentially expressed between two groups of cells. Groups can be defined by columns in the cell metadata. Different types of tests can be used and input data for testing can be the different assays as well as the computed dimensionality reductions. Resulting _p_-values are adjusted using the Bonferroni method. The names of differentially expressed genes per cluster, alongside statistical measures and additional gene annotation are written to file.

```{r}
#| label: deg_analysis_compute_degs
#| results: asis

if (have_deg_comparisons) {
    # Run DEG tests (sequential for now)
    deg_results_list = DegsRunTests(contrasts_list[deg_tests_idx])
    
    # Generate scatter plots
    deg_results_list = purrr::map(deg_results_list, function(result) {
        result[["scatter_plot"]] = DegsScatterPlot(result)
        return(result)
    })
    
    # Generate volcano plots
    deg_results_list = purrr::map(deg_results_list, function(result) {
        result[["volcano_plot"]] = DegsVolcanoPlot(result)
        return(result)
    })
    
    # Regroup list so that subset comparisons are grouped together
    deg_results_list = split(deg_results_list,
                             purrr::map_chr(deg_results_list, function(r) return(r$name)) )
    
    # Write results to files
    for (i in seq_along(deg_results_list)) {
        deg_results = deg_results_list[[i]]
        
        # Get DEG tables and add names if multiple subsets were analysed
        deg_tables = purrr::map(deg_results, function(deg_result) return(deg_result$results))
        if ("subset_column" %in% names(deg_results[[1]])) {
            deg_table_names = purrr::map_chr(deg_results, function(deg_result) {
                return(paste(deg_result$subset_group, collapse=","))
            }) %>% strtrim(31)
            names(deg_tables) = deg_table_names
        }
        
        # Add annotation to the DEG tables
        
        DegsWriteToFile(deg_results, file.path(module_dir, "results"))
    }
} else {
    deg_results_list = list()
    CalloutBox("No DEG tests requested.", type="note")
}
```

```{r}
#| label: tbl-deg_analysis_deg_table
#| tbl-cap: "Summary of the DEG tests"
#| eval: !expr have_deg_comparisons
#| include: !expr have_deg_comparisons

# Create a summary table of all DEG comparisons
deg_summary_table = purrr::map_depth(deg_results_list, 2, function(result) {
    # Get comparison name, condition column and values, subset column and subset group. . If multiple, join by '+'.
    summary_table = data.frame(Comparison=result[["name"]],
               Condition=result[["condition_column"]], 
               Group1=paste(result[["condition_group1"]], collapse="+"), 
               Group2=paste(result[["condition_group2"]], collapse="+"))
    if ("subset_column" %in% names(result)) {
        summary_table$Subset = result[["subset_column"]]
        summary_table$SubsetGroup = paste(result[["subset_group"]], collapse="+")
    }
    
    # Get the number of DEG with adjusted p-value < padj and absolute log2 foldchange >= log2FC (log2 foldchange threshold)
    padj = result[["padj"]]
    log2FC = result[["log2FC"]]
    deg_table = result[["results"]] %>%
        dplyr::filter(p_val_adj < padj & abs(avg_log2FC ) >= log2FC)
    summary_table$DEG = nrow(deg_table)
    summary_table$DEG_up = sum(deg_table$avg_log2FC>0)
    summary_table$DEG_down = sum(deg_table$avg_log2FC<0)
    
    return(summary_table)
}) %>% dplyr::bind_rows()

if ("Subset" %in% colnames(deg_summary_table)) {
    deg_summary_table = deg_summary_table %>% 
        dplyr::select(Comparison, Condition, Group1, Group2, Subset, SubsetGroup, DEG, DEG_up, DEG_down)
}

gt::gt(deg_summary_table) %>%
    gt::sub_missing(columns=1:ncol(deg_summary_table), missing_text="")
```

```{r}
#| label: deg_analysis_results
#| results: asis
#| eval: !expr have_deg_comparisons
#| include: !expr have_deg_comparisons

# Generate report sections for each DEG comparison
if (have_deg_comparisons) {
    # Iterate over the comparisons
    for (deg_results in deg_results_list) {
        # deg_results: Result list for this comparison
        
        # Show an overview of the comparison
        # Chunk template
        chunk_template_overview = "
### {{name}}

This is the general configuration for the DEG analysis for this comparison:

* **condition column**: '{{condition_column}}'
* **condition group 1**: '{{condition_group1}}'
* **condition group 2**: '{{condition_group2}}'
* **assay**: '{{assay}}'
* **slot**: '{{slot}}'
* **test**: '{{test}}'
* **maximum adjusted p-value**: '{{padj}}'
* **minimum absolute log2 foldchange**: '{{log2FC}}'
* **minimum percentage of cells**: '{{min_pct}}'
* **latent vars**: '{{latent_vars}}'
* **output file**: 'degs_{{name}}_results.xlsx'

Here is the overview of the results:

\`\`\`{r}
#| label: tbl-deg_analysis_{{name}}
#| tbl-cap: DEG results for comparison '{{name}}'

deg_results_table = deg_summary_table %>% 
    dplyr::filter(Comparison == '{{name}}') %>%
    dplyr::select(Condition, Group1, Group2, Subset, SubsetGroup, DEG, DEG_up, DEG_down)
    
gt::gt(deg_results_table) %>%
    gt::sub_missing(columns=1:ncol(deg_results_table), missing_text='')
\`\`\`
"
        
        # Fill in the overview chunk template and render/knit
        chunk_filled = knitr::knit_expand(text=chunk_template_overview,
                                           condition_column=deg_results[[1]]$condition_column,
                                           condition_group1=deg_results[[1]]$condition_group1,
                                           condition_group2=deg_results[[1]]$condition_group2,
                                           assay=deg_results[[1]]$assay,
                                           slot=deg_results[[1]]$slot,
                                           test=deg_results[[1]]$test,
                                           padj=deg_results[[1]]$padj,
                                           log2FC=deg_results[[1]]$log2FC,
                                           min_pct=deg_results[[1]]$min_pct,
                                           latent_vars=deg_results[[1]]$latent_vars,
                                           name=deg_results[[1]]$name)
        if(interactive()) {
            print(EvalKnitrChunk(chunk_filled))
        } else {
            chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
            cat('\n', chunk_filled, '\n', sep='\n')
        }
        
        # Now show the result(s) for this comparison. If multiple subsets were analysed, there will be multiple results.
        for (j in seq_along(deg_results)) {
            deg_result = deg_results[[j]]
            # deg_result: Each result for this comparison
            
            # Add a header if there are multiple subsets
            if ("subset_column" %in% names(deg_result)) {
                cat(FormatString("#### Subset {deg_result$subset_column}: {deg_result$subset_group*}"), '\n\n')
            }

            # Show top 5 genes as well as a scatter and volcano plot
            # Chunk template
            chunk_template_comparison = "
\`\`\`{r}
#| label: tbl-deg_analysis_{{name}}_{{j}}
#| tbl-cap: Top five genes tested for comparison '{{name}}' 

top5_degs = deg_result$results %>% 
    dplyr::select(gene, avg_log2FC, p_val_adj, condition1, condition2) %>%
    head(5)
    
gt::gt(top5_degs)
\`\`\`


\`\`\`{r}
#| label: fig-deg_analysis_results_{{name}}_{{j}}
#| fig-cap: Scatter and volcano plot for comparison '{{name}}'
#| fig-height: 4

patchwork::wrap_plots(deg_result$scatter_plot, deg_result$volcano_plot)
\`\`\`
"
            # Fill in the comparison chunk template and render/knit
            chunk_filled =  knitr::knit_expand(text=chunk_template_comparison, name=deg_result$name, j=j)
            if(interactive()) {
                print(EvalKnitrChunk(chunk_filled))
            } else {
                chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
                cat('\n', chunk_filled, '\n', sep='\n')
            }
        }
    }
}
```

## Software

```{r}
#| label: deg_analysis_save_software

sessioninfo = ScrnaseqSessionInfo(getwd()) %>% as.data.frame()
gt(sessioninfo)
```

## Parameter

```{r}
#| label: deg_analysis_save_parameter  

paraminfo = ScrnaseqParamsInfo(param()) %>% as.data.frame()
gt(paraminfo)
```

```{r}
#| label: deg_analysis_save_seurat

# This will overwrite the (bugged) function SeuratObject::SaveSeuratRds with the content of our function SaveSeuratRds_Fixed
assignInNamespace("SaveSeuratRds",SaveSeuratRds_Fixed, ns="SeuratObject")

# Save Seurat object and layer data
with_progress({
  SaveSeuratRdsWrapper(sc,
                       on_disk_layers=on_disk_counts,
                       outdir=file.path(module_dir, "sc"))
}, enable=verbose)
```

```{r}
#| label: deg_analysis_finish

# Stop multisession workers
plan(sequential)
```

