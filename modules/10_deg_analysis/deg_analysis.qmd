---
# Module-specific parameters (that are not already in the profile yaml)
# Defaults
params:
  # Name of the module used in configurations
  module: "deg_analysis"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/10_deg_analysis"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  # NOTE: Change to null if all modules are implemented and sc objects are written
  prev_module_dir: null
  
  # Default assay
  default_assay: null

  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. 
  # Computations will access only the relevant parts of the data. 
  # Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: false
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. 
  # This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). 
  # Once done, matrix directories will be copied back to the module directory. 
  # The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: false
  
  # Number of cores to use for computations
  cores: 4
  
  # Contrasts
  # Add entries below keyword 'value'.
  # Each entry has a unique name and the following keys:
  #
  #  condition_column: Categorial column in the barcode metadata (required)
  #  condition1: Condition levels in group 1 (required)
  #                    Use 'level1+level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #  condition2: Condition levels in group 2 (required)
  #                    Use 'level1,level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset
  #
  # subset_column: Categorial column in the barcode metadata to subset for tests (default: null)
  #                For example, use 'orig.ident' for sample and 'seurat_clusters' for cluster 
  # subset_group: Levels to subset (default: null)
  #               Use 'level1+level2' to use multiple levels for one subset or 'level1+level2,level3' for multiple subsets
  #               Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #               Use '*' to use all levels as subsets
  #               Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line
  #               Original barcode refers to the one used in the dataset
  #
  # bulk_by: Generate bulk samples for each condition through aggregating barcodes over one or more other barcode columns (default: null)
  #          Control the number of barcodes aggregated per bulk sample with downsample_n
  #          If categorial covariates are used, they will be included for aggregating the barcodes
  #
  # pseudobulk_samples: Generate this number of pseudo-bulk samples for each condition (default: null)
  #                     If bulk_by is used, generate pseudo-bulk samples for each bulk_by combination 
  #                     Control the number of barcodes aggregated per pseudo-bulk sample with downsample_n.
  #                     If categorial covariates are used, they will be included for aggregating the barcodes.
  #
  # assay: Assay with counts data, dimensionality reduction or barcode metadata columns to test on (default: default assay of Seurat object)
  # layer: In case of Seurat assay, which layer/slot to use (default: 'data')
  #        Should be set specific for the test.
  # downsample_barcodes: Downsample each group to at most n barcodes (default: null)
  # 
  # test: Type of test for identifying differentially expressed genes (default: 'wilcox')
  #       Can be 'wilcox', 'bimod', 'roc', 't', 'negbinom', 'poisson', 'LR', 'MAST', 'DESeq2', 'DESeq2LRT'.
  #       Tests 'DESeq2' and 'DESeq2LRT' can only be used together with 'bulk_by'/'pseudobulk_samples'. 
  # covariate: One or more columns to include as covariates (batches) for testing (default: null).
  #            The following tests can use covariates: 'LR', 'poisson', 'negbinom', 'MAST', 'DESeq2', 'DESeq2LRT'.
  #
  # design: For DESeq2 tests, specify a design formula for testing. (default: null). 
  #         Overwrites the 'covariate' entry. Include the term 'condition_groups' for specifying the condition in the design formula.
  #         For 'DESeq2LRT', specify a design formula for the full model and the reduced model.
  # deseq2_results_args: For DESeq2 tests, additional arguments (format key: value) passed to the DESeq2 results function (default: null)
  # 
  # padj: Maximum adjusted p-value (default: 0.05)
  # log2FC: Minimum absolute log2 fold change (default: 0)
  # min_pct: Minimum percentage of barcodes expressing a feature in one group (default: 0.01)
  #
  # ora_genesets: Genesets to use for over-representation analysis (default: null).
  #               See the global 'genesets' parameter for more information.
  # gsea_genesets: Genesets to use for over-representation analysis (default: null).
  #               See the global 'genesets' parameter for more information.
  # gsea_deseq2: Calculate fold changes for GSEA with DESeq2 instead of simplying dividing the means (default: false).
  #              Allows to use the parameters 'covariate', 'design' and 'deseq2_results_args'.
  #              Can only be used together with 'bulk_by'/'pseudobulk_samples'.
  #
  contrasts:
      value:
          # Compare pbmc_1k vs pbmc_5k
          - Comparison1:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
          # Compare pbmc_1k vs pbmc_5k for clusters 1,2,3+4
          - Comparison2:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
                subset_column: "seurat_clusters"
                subset_group: "1,2,3+4"
          # Compare pbmc_1k vs pbmc_5k. Bulk cells by cluster and condition to generate replicates. 
          # Use DESeq2 and a specific design that includes seurat_clusters as covariate in the model.
          - Comparison3:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
                bulk_by: "seurat_clusters"
                test: "DESeq2"
                design: "~ condition_groups + seurat_clusters"
                gsea_deseq2: true
          # Compare pbmc_1k vs pbmc_5k. Generate 5 pseudo-bulk replicates per cluster and condition. 
          # Use DESeq2 with a LRT test that compares two different models across seurat_clusters.
          - Comparison4:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
                bulk_by: "seurat_clusters"
                pseudobulk_samples: 5
                test: "DESeq2LRT"
                design: 
                - "~ condition_groups + seurat_clusters"
                - "~ seurat_clusters"
          # Compare pbmc_1k vs pbmc_5k. Test for differences in nFeature_RNA and nCount_RNA.
          - Comparison5:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
                assay: 
                - "nFeature_RNA"
                - "nCount_RNA"
          # Compare pbmc_1k vs pbmc_5k. Test for differences in principal components.
          - Comparison6:
                condition_column: "orig.ident"
                condition1: "pbmc_1k"
                condition2: "pbmc_5k"
                assay: "rna_pca"

        
  # Excel or csv file with contrasts
  contrasts_file: null
  
  # Run DEG tests: True, false or a list with contrast names
  run_deg:
    - "Comparison1"
    - "Comparison2"
    - "Comparison3"
    - "Comparison4"
    - "Comparison5"
    - "Comparison6"
  
  # Run over-representation analysis (ORA) on DEGs: True, false or a list with contrast names.
  # Uses genesets from MSigDB (https://www.gsea-msigdb.org/gsea/msigdb) or user-defined genesets (see below).
  run_ora:
    - "Comparison1"
    - "Comparison2"
    - "Comparison3"
    - "Comparison4"
  
  # When using MSigDB, the name of the species in the database. If null, the name will be inferred from the 'species' parameter.
  # For example: homo_sapiens => Homo sapiens
  msigdb_species: null
  
  # User-defined genesets in Excel or CSV file(s) to use for ORA or GSEA instead of MSigDB. The files should have these columns: gs_cat,
  # gs_subcat, gs_name, gene_id, gene_symbol. If null, MSigDB will be used.
  geneset_files: null
  
  # Genesets to use for ORA or GSEA. List entries should have the form gs_cat:gs_subcat:gs_name. Wildcards are allowed. 
  # For example, when using MSigDB, 'C5:GO:BP:*' will use all genesets in the C5 category, GO:BP (gene ontology, biological process) subcategory. Multiple entries can be provided and result in multiple analyses.
  # Genesets can also specified in the contrasts section.
  genesets: 
  - "C5:GO:BP:*"
  - "C5:GO:MF:*"
  
  # Run geneset enrichment analysis (GSEA) on expressed genes: True, false or a list with contrast names.
  # Uses genesets from MSigDB (https://www.gsea-msigdb.org/gsea/msigdb) or user-defined genesets (see below).
  run_gsea:
    - "Comparison1"
    - "Comparison2"
    - "Comparison3"
    - "Comparison4"
  
  # Top n number of genesets, ranked by NES, for which to produce GSEA plots (showing running score and ranked list metrics) per analysis. These plots will not be included in the report but can be found in the results directory.
  gsea_num_plots: 5
  
  # Export the contrasts. This include per contrast a counts table and a sample information table.
  export_contrasts: true
    
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# DEG Analysis

```{r}
#| label: setup

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "scrnaseq")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)
library(BiocParallel)
library(patchwork)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir
```

```{r}
#| label: deg_analysis_preparation

# CODE
# Working directory is automatically back to scrnaseq2 at this point
# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")
source("R/functions_degs.R")

# Be verbose or not
verbose = param("verbose")

# Parallelisation config for all functions that use the future framework
plan(multisession, workers=param("cores"))

# Parallelisation config for all functions that use the BiocParallel framework
register(SnowParam(workers=param("cores"), type="SOCK", RNGseed=getOption("random_seed"))) 

# Parallelisation config for BLAS threading. Currently set to 1 because there does not seem to be a performance gain
# but may be relevant for very large projects.
RhpcBLASctl::blas_set_num_threads(1)

# DIRECTORIES
# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# SEURAT OBJECT
# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatString("Could not find a sc.rds file in {prev_module_dir}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
} else {
  on_disk_path = file.path(module_dir, "sc")
}

# Set default assay standard
default_assay = param("default_assay")
if (is.null(default_assay)) default_assay = Seurat::DefaultAssay(sc)
Seurat::DefaultAssay(sc) = default_assay

# CONTRASTS
# Parse the contrasts information
if (is.character(param("contrasts")) && file.exists(param("contrasts"))) {
  # Read from file
  contrasts_file = param("contrasts")
  
  # Sheet number appended?
  sheet = 1
  if (grepl(":\\d+$", deg_contrasts_file)) {
    sheet = gsub(pattern=".+:(\\d+)$", replacement="\\1", x=contrasts_file) %>% as.integer()
    contrasts_file = gsub(pattern=":\\d+$", replacement="", x=contrasts_file)
  }
  
  # Read Excel file and split into list, remove NA entries
  contrasts_content = readxl::read_excel(contrasts_file, sheet=1, col_names=TRUE)
  contrasts_content = split(contrasts_list, seq(nrow(contrasts_content)))
  
  contrasts_content = purrr::map(contrasts_content, function(contrast) {
      is_na = is.na(contrast)
      if (sum(is_na) > 0) contrast[[is_na]] = NULL
      return(contrast)
  })

} else {
  contrasts_content = param("contrasts")
    
  # Read from yaml parameter and prepare list
  contrasts_content = purrr::map(seq(contrasts_content), function(i) {
      contrast = contrasts_content[[i]][[1]]
      contrast$name = names(contrasts_content[[i]])
      return(contrast)
  })
}

# For each contrast, collect the necessary information (which groups to compare, the assay to use, etc).
# Note: Each contrast entry is a list either of length 1 (if there is only one comparison) or of length >1 (if the comparison is done for multiple subsets). The names of the list elements are the names of the contrasts.
contrasts_list = NewContrastsList(sc, contrasts_content, type="deg")

# For each contrast, prepare an individual Seurat object for the comparison. If multiple subsets are analysed, prepare multiple objects. Bulk-aggregate if requested. Downsample if requested.
# Note: This is a list of contrasts with of lists of comparisons, so we use map_depth need to specify the depth of the list.
contrasts_list = purrr::map_depth(contrasts_list, .depth=2, function(contrast) return(PrepareDegContrast(sc, contrast, cast_to_sparse=FALSE)))

# Which contrasts should be DEG tested?
run_deg = param("run_deg")
if (is.logical(run_deg)) {
    # If TRUE all, else none
    if (run_deg) {
        run_deg = names(contrasts_list)
    } else {
        run_deg = c()
    }
} else if (is.character(run_deg)) {
    # If character, only those
    if (!all(run_deg %in% names(contrasts_list))) {
      stop("Not all contrasts specified for DEG analysis are defined in the contrasts list.")
    }
}
have_deg_comparisons = length(run_deg) > 0

# For the contrasts that are DEG tested: for which should also over-representation analysis be run?
run_ora = param("run_ora")
if (is.logical(run_ora)) {
    # if TRUE all, else none
    if (run_ora) {
        run_ora = run_deg
    } else {
        run_ora = c()
    }
} else if (is.character(run_ora)) {
    # if character, only those
    if (!all(run_deg %in% names(contrasts_list))) {
      stop("Not all contrasts specified for over-representation analysis are defined in the contrasts list.")
    }
}
# ORA reuqires a DEG analysis as input
if (!all(run_ora %in% run_deg)) {
  stop("Not all contrasts for specified over-representation analysis are also tested for DEGs.")
}
# ORA is only supported for counts data and cannot be used when testing barcode metadata or reductions
for(name in run_ora){
  data_type = contrasts_list[[name]][[1]][["data_type"]]
  if (data_type != "feature_data") stop(FormatString("Comparison {name} cannot be used for over-representation analysis. Please remove for parameter 'run_ora'."))

}
have_ora = length(run_ora) > 0

# Which contrasts should be analysed with GSEA?
run_gsea = param("run_gsea")
if (is.logical(run_gsea)) {
    # if TRUE all, else none
    if (run_gsea) {
        run_gsea = names(contrasts_list)
    } else {
        run_gsea = c()
    }
} else if (is.character(run_gsea)) {
    # if character, only those
    if (!all(run_gsea %in% names(contrasts_list))) {
      stop("Not all contrasts specified for GSEA analysis are defined in the contrasts list.")
    }
}
# GSEA is only supported for counts data and cannot be used when testing barcode metadata or reductions
for (name in run_gsea){
  data_type = contrasts_list[[name]][[1]][["data_type"]]
  if (data_type != "feature_data") stop(FormatString("Comparison {name} cannot be used for geneset-enrichment analysis. Please remove for parameter 'run_gsea'."))

}
have_gsea = length(run_gsea) > 0

# Export contrasts?
export_contrasts = param("export_contrasts")
if (is.logical(export_contrasts)) {
    # if TRUE all, else none
    if (export_contrasts) {
        export_contrasts = names(contrasts_list)
    } else {
        export_contrasts = c()
    }
} else if (is.character(export_contrasts)) {
    # if character, only those
    if (!all(export_contrasts %in% names(contrasts_list))) {
      stop("Not all contrasts specified for export are defined in the contrasts list.")
    }
}
have_export_contrasts = length(export_contrasts) > 0
```

## Differentially expressed genes

If requested, we identify genes that are differentially expressed (DEGs) between two groups of cells. Groups can be defined by columns in the cell metadata. Different types of tests can be used and input data for testing can be the different assays as well as the computed dimensionality reductions. Resulting _p_-values are adjusted using the Bonferroni method. The names of differentially expressed genes per cluster, alongside statistical measures and additional gene annotation are written to file.

```{r}
#| label: deg_analysis_compute_degs
#| results: asis

if (have_deg_comparisons) {
    # Run DEG tests (sequential for now)
    deg_results_list = purrr::map_depth(contrasts_list[run_deg], .depth=2, function(contrast) {
        return(DegsRunTest(contrast))
    })
    
    # Generate plots
    deg_results_list = purrr::map_depth(deg_results_list, .depth=2, function(deg_result) {
        deg_result[["scatter_plot"]] = DegsScatterPlot(deg_result)
        deg_result[["volcano_plot"]] = DegsVolcanoPlot(deg_result)
        return(deg_result)
    })
    
    # Write results to files
    for (i in seq_along(deg_results_list)) {
      deg_results = deg_results_list[[i]]
        
      # Get DEG tables for each comparison and add names (needed if multiple subsets were analysed)
      deg_tables = purrr::map(deg_results, "results")
      if (is.null(names(deg_tables)) & length(deg_tables) == 1) names(deg_tables) = "Results"
      
      # Add Ensembl annotation to the DEG tables. This is only done when genes are tested not reductions or barcode metadata.
      # This table is empty if Ensembl was not used for gene annotations.
      data_type = deg_results[[1]]$data_type
      if (data_type == "feature_data") {
        assay = deg_results[[1]]$assay
        annot_ensembl = sc[[assay]][[]] %>% dplyr::select(dplyr::starts_with("ensembl_"))
      } else {
        annot_ensembl = data.frame()
      }
      
      # Collect configuration
      deg_configuration_table = ContrastConfigurationTable(deg_results[[1]], 
                                                           config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "log2FC", "min_pct", "downsample_n", "covariate", "design", "deseq2_results_args"))
      if ("subset_column" %in% names(deg_results[[1]])) {
          subset_group = purrr::map_chr(deg_results, function(deg_result) return(paste(deg_result$subset_group, collapse="+"))) %>%
           paste(collapse=",")
          deg_configuration_table[deg_configuration_table$Config == "subset_groups", "Value"] = subset_group
      }
      
      # Write to file
      outfile = paste0("degs_", deg_results[[1]]$name, ".xlsx")
      DegsWriteToFile(deg_tables,
                      annotation=annot_ensembl,
                      file=file.path(module_dir, "results", outfile),
                      parameter=deg_configuration_table)
    }
} else {
    deg_results_list = list()
    CalloutBox("No DEG tests requested.", type="note")
}
```

```{r}
#| label: tbl-deg_analysis_deg_summary
#| tbl-cap: "Summary of the DEG tests"
#| eval: !expr have_deg_comparisons
#| include: !expr have_deg_comparisons

# Create a summary table of all DEG comparisons
deg_summary_table = purrr::map_depth(deg_results_list, .depth=2, function(deg_result) {
    # Get comparison name, condition column and values, subset column and subset group. . If multiple, join by '+'.
    summary_table = data.frame(Comparison=deg_result[["name"]],
               Group=deg_result[["condition_column"]], 
               Condition1=paste(deg_result[["condition1"]], collapse="+"), 
               Condition2=paste(deg_result[["condition2"]], collapse="+"))
    if ("subset_column" %in% names(deg_result)) {
        summary_table$Subset = deg_result[["subset_column"]]
        summary_table$SubsetGroup = paste(deg_result[["subset_group"]], collapse="+")
    } else {
        summary_table$Subset = ""
        summary_table$SubsetGroup = ""
    }
    
    # Get the number of significant genes with adjusted p-value < padj
    padj = deg_result[["padj"]]
    deg_table = deg_result[["results"]] %>% dplyr::filter(p_val_adj < padj)
    
    # For counts data, we also apply an absolute log2 foldchange >= log2FC (only when testing count data)
    if (deg_result[["data_type"]] == "feature_data") {
      log2FC = deg_result[["log2FC"]]
      deg_table = deg_table %>% dplyr::filter(abs(avg_log2FC) >= log2FC)
    }
    
    # Find sign, sign upregulated and sign downregulated
    fc_col = dplyr::case_match(deg_result[["data_type"]], "feature_data" ~ "avg_log2FC", "reduction" ~ "avg_diff", "barcode_metadata" ~ "avg_diff")
    summary_table$Sign = nrow(deg_table)
    summary_table$Sign_up = sum(deg_table[[fc_col]]>0)
    summary_table$Sign_down = sum(deg_table[[fc_col]]<0)
    
    return(summary_table)
}) %>% 
    purrr::flatten() %>% 
    dplyr::bind_rows()

deg_summary_table = deg_summary_table %>% 
    dplyr::select(Comparison, Group, Condition1, Condition2, Subset, SubsetGroup, Sign, Sign_up, Sign_down)

gt(deg_summary_table) %>%
    sub_missing(columns=1:ncol(deg_summary_table), missing_text="")
```

```{r}
#| label: deg_analysis_deg_results
#| results: asis
#| eval: !expr have_deg_comparisons
#| include: !expr have_deg_comparisons

# Generate report sections for each DEG comparison
if (have_deg_comparisons) {
  # Iterate over the comparisons
  for (deg_results in deg_results_list) {
    # deg_results: Result list for this comparison
    
    # Print name in header
    name = deg_results[[1]]$name
    cat(FormatString("### {name}\n\n", quote=FALSE))
    
    # Collect configuration
    deg_configuration_table = ContrastConfigurationTable(deg_results[[1]], 
                                                         config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "log2FC", "min_pct", "downsample_n", "covariate", "design", "deseq2_results_args"))
    if ("subset_column" %in% names(deg_results[[1]])) {
      subset_group = purrr::map_chr(deg_results, function(deg_result) return(paste(deg_result$subset_group, collapse="+"))) %>%
        paste(collapse=",")
      deg_configuration_table[deg_configuration_table$Config == "subset_groups", "Value"] = subset_group
    }
    deg_configuration_table = dplyr::filter(deg_configuration_table, Value!="-")
    
    # Configuration chunk template
    chunk_template_deg_configuration = "
\`\`\`{r}
#| label: tbl-deg_analysis_deg_configuration_{{name}}
#| tbl-cap: 'Configuration for DEG comparison {{name}}'

gt(deg_configuration_table)
\`\`\`
"
    # Then fill out the configuration chunk template and render/knit
    chunk_filled =  knitr::knit_expand(text=chunk_template_deg_configuration, 
                                         name=name)
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, '\n', sep='\n')
    }
    
    # Now show the result(s) for this comparison. If multiple subsets were analysed, there will be multiple results.
    # Note: Since there can be multiple results, we include i as a counter to make them unique.
    cat("Here are the results:\n\n")
    for (i in seq_along(deg_results)) {
      # deg_result: DEGs for this comparison
      deg_result = deg_results[[i]]
      name = deg_result$name

      # Add a header if there are multiple subsets
      if ("subset_column" %in% names(deg_result)) {
        subset_column = deg_result$subset_column
        subset_group = paste(deg_result$subset_group, collapse="+")
        cat(FormatString("#### {i}. {subset_column} - '{subset_group}'", quote=FALSE), '\n\n')
      } else {
        subset_column = ""
        subset_group = ""
      }
      
      # Chunk template for comparison with number of DEG, top 5 genes as well as scatter and volcano plot
      chunk_template_deg_comparison = "
\`\`\`{r}
#| label: tbl-deg_analysis_deg_summary_{{name}}_{{i}}
#| tbl-cap: 'DEG results for {{name_subset}}'

deg_results_table = deg_summary_table %>% 
    dplyr::filter(Comparison == '{{name}}', SubsetGroup=='{{subset_group}}') %>%
    dplyr::select(Group, Condition1, Condition2, Subset, SubsetGroup, Sign, Sign_up, Sign_down)
    
gt(deg_results_table) %>%
    sub_missing(columns=1:ncol(deg_results_table), missing_text='') %>%
    fmt_number(columns=2:ncol(deg_results_table), decimals=3, use_seps=FALSE)
\`\`\`

\`\`\`{r}
#| label: tbl-deg_analysis_deg_topfive_{{name}}_{{i}}
#| tbl-cap: 'Top five results for {{name_subset}}'


fc_col = dplyr::case_match(deg_result[['data_type']], 'feature_data' ~ 'avg_log2FC', 'reduction' ~ 'avg_diff', 'barcode_metadata' ~ 'avg_diff')

top5_degs = deg_result$results %>% 
    dplyr::select(gene, !!sym(fc_col), p_val_adj, condition1, condition2) %>%
    head(5)
    
gt(top5_degs)
\`\`\`

\`\`\`{r}
#| label: fig-deg_analysis_deg_plots_{{name}}_{{i}}
#| fig-cap: 'Scatter and volcano plot for {{name_subset}}'
#| fig-height: 4

patchwork::wrap_plots(deg_result$scatter_plot, deg_result$volcano_plot)
\`\`\`
"

      
      # Fill in the comparison chunk template and render/knit
      # This will include a top 5 table as well as the volcano and scatter plots
      chunk_filled =  knitr::knit_expand(text=chunk_template_deg_comparison, 
                                         name=name,
                                         name_subset=ifelse(nchar(subset_group) > 0, 
                                                            FormatString("{name}, {subset_column}: {subset_group}", quote=FALSE), 
                                                            name),
                                         subset_group=subset_group,
                                         i=i)
      if(interactive()) {
        print(EvalKnitrChunk(chunk_filled))
      } else {
        chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
        cat('\n', chunk_filled, '\n', sep='\n')
      }
    }
  }
}
```

## Over-representation analysis

Over-representation analysis (ORA) tests if functional categories are enriched in the DEGs.

```{r}
#| label: deg_analysis_run_ora
#| eval: !expr have_ora
#| include: !expr have_ora

if (have_ora) {
  # Custom genesets for over-representation analysis
  ora_geneset_files = param("geneset_files")

  # Get genesets to test from MSigDB or user input file
  ora_term2gene_db = DegsGetGenesets(msigdb_species=param("msigdb_species") %||% param("species"), 
                                      is_msigdb_species_name = !is.null(param("msigdb_species")),
                                      geneset_files=ora_geneset_files)

  # Run overrepresentation analysis (ORA)
  ora_results_list = purrr::map_depth(deg_results_list[run_ora], .depth=2, function(deg_result) {

    # Run ORA and get results
    ora_result = DegsRunOraTest(deg_result=deg_result,
                             term2gene_db=ora_term2gene_db,
                             genesets=deg_result[["ora_genesets"]] %||% param("genesets"))
    
    # Remove scatter and volcano plot
    ora_result[["volcano_plot"]] = NULL
    ora_result[["scatter_plot"]] = NULL
    
    # Also add bar plots with the top 15 terms
    ora_result[["plots"]] = purrr::map(ora_result[["results"]], function(ora) {
        # If there are no results, return NULL
        if (nrow(ora) == 0) return(NULL)
        
        p = enrichplot:::dotplot(ora, color='p.adjust', x='FoldEnrichment', size='Count', font.size=11, showCategory=15, label_format=40) +
            AddPlotStyle() +
            scale_fill_gradient(high="#327eba", low="#e06663",
                                 breaks=scales::pretty_breaks(4), labels=scales::scientific) +
            scale_size_continuous(breaks=scales::pretty_breaks(3)) +
            xlab("Fold enrichment (list vs background)")
        
        return(p)
    })
    
    return(ora_result)
  })

  # Write ORA results to files
  for (i in seq_along(ora_results_list)) {
    ora_results = ora_results_list[[i]]
    
    # Get ORA results for each comparison
    ora_tables = purrr::map(ora_results, function(ora_result) {
      ora_result = ora_result[["results"]]
      
      # If no ORA was done, this will be an empty list
      if (length(ora_result) == 0) return(NULL)
      
      # If multiple gene sets were analysed, join the result tables
      ora_table = purrr::map_dfr(names(ora_result), function(set_name) {
        ora = ora_result[[set_name]]
        ora_tbl = ora %>% 
          as.data.frame() %>%
          dplyr::mutate(GeneSet=set_name, .before=1)
        return(ora_tbl)
      })
      
      return(ora_table)
    })
    ora_tables = purrr::discard(ora_tables, is.null)
    if (length(ora_tables) == 0) next
    if (is.null(names(ora_tables)) & length(ora_tables) == 1) names(ora_tables) = "Results"
    
    # Collect configuration
    ora_configuration_table = ContrastConfigurationTable(ora_results[[1]], 
                                                         config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "log2FC", "min_pct", "downsample_n", "covariate", "design", "deseq2_results_args", "ora_genesets"))
    if ("subset_column" %in% names(ora_results[[1]])) {
        subset_group = purrr::map_chr(ora_results, function(ora_result) return(paste(ora_result$subset_group, collapse="+"))) %>%
         paste(collapse=",")
        ora_configuration_table[ora_configuration_table$Config == "subset_groups", "Value"] = subset_group
    }
    
    # Write to file
    outfile = paste0("ora_", names(ora_results_list)[i], ".xlsx")
    DegsWriteOraToFile(ora_tables,
                       file=file.path(module_dir, "results", outfile),
                       parameter=ora_configuration_table)
  }
}
```

```{r}
#| label: deg_analysis_ora_results
#| results: asis
#| eval: !expr have_ora
#| include: !expr have_ora

# Generate report sections for each ORA analysis
if (have_ora) {
  # Iterate over the comparisons
  for (ora_results in ora_results_list) {
    # ora_results: Result list for this comparison
    
    # Print name in header
    name = ora_results[[1]]$name
    cat(FormatString("### {name}\n\n", quote=FALSE))
    
    # Collect configuration
    ora_configuration_table = ContrastConfigurationTable(ora_results[[1]], 
                                                         config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "log2FC", "min_pct", "downsample_n", "covariate", "design", "deseq2_results_args", "ora_genesets"))
    if ("subset_column" %in% names(ora_results[[1]])) {
        subset_group = purrr::map_chr(ora_results, function(ora_result) return(paste(ora_result$subset_group, collapse="+"))) %>%
         paste(collapse=",")
        ora_configuration_table[ora_configuration_table$Config == "subset_groups", "Value"] = subset_group
    }
    ora_configuration_table = dplyr::filter(ora_configuration_table, Value!="-")
    
    # Configuration chunk template
    chunk_template_ora_configuration = "
\`\`\`{r}
#| label: tbl-deg_analysis_ora_configuration_{{name}}
#| tbl-cap: 'Configuration for ORA comparison {{name}}'

gt(ora_configuration_table)
\`\`\`
"
    # Then fill out the configuration chunk template and render/knit
    chunk_filled =  knitr::knit_expand(text=chunk_template_ora_configuration, 
                                         name=name)
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, '\n', sep='\n')
    }
    
    # Now show the result(s) for this comparison. If multiple subsets were analysed, there will be multiple results.
    # Note: Since there can be multiple results, we include i as a counter to make them unique.
    cat("Here are the results:\n\n")
    for (i in seq_along(ora_results)) {
      # ora_result: ORA analysis for this subset comparison (includes tables and plots)
      ora_result = ora_results[[i]]
      
      # Add a header if there are multiple subsets
      if ("subset_column" %in% names(ora_result)) {
        subset_column = ora_result$subset_column
        subset_group = paste(ora_result$subset_group, collapse="+")
        cat(FormatString("#### {i}. {subset_column} - '{subset_group}'", quote=FALSE), '\n\n')
      } else {
        subset_column = ""
        subset_group = ""
      }

      # Now split into tables and plots
      ora_plots = ora_result[["plots"]]
      ora_result = ora_result[["results"]]
      
      # Now plot ORA results (if available)
      if (length(ora_result) > 0) {
        # For each ORA result, fill in the ORA chunk template and render/knit
        # Note: Since there can be multiple results, we include j as a counter to make them unique.
        # Layout is two columns
        cat("::: {.panel-tabset}\n")
        for (j in seq_along(ora_result)) {
          # ORA result for one gene set
          ora = ora_result[[j]]
          ora_res_name = names(ora_result)[j]
          ora_plot = ora_plots[[j]]
          
          # Print some general stats
          cat(FormatString("##### {ora_res_name}\n\n", quote=FALSE))
          cat("* geneset name:", ora_res_name, "\n")
          genesets = ora@geneSets
          cat("* number of terms in geneset:", length(genesets), "\n")
          genesets_lengths = purrr::map_int(genesets, length)
          cat("* thereof tested (at least 10, at most 500 genes in geneset):", sum(genesets_lengths >= 10 & genesets_lengths<=500), "\n")
          cat("* thereof significant (adjusted p-value < 0.05):", nrow(ora), "\n")
          cat("\n")
          
          # Chunk template for ORA
          chunk_ora = "
\`\`\`{r}
#| label: fig-deg_analysis_deg_ora_{{name}}_{{i}}_{{j}}
#| fig-cap: 'Top 10 overrepresented terms of geneset {{ora_res_name}} for {{name_subset}}'

# Plot the top terms
ora_plot
\`\`\`
"
          
          # Fill in the ORA chunk template and render/knit
          # This will generate an ORA barplot
          chunk_filled = knitr::knit_expand(text=chunk_ora,
                                            name=name,
                                            name_subset=ifelse(nchar(subset_group)>0, 
                                                               FormatString("{name}, {subset_column}: {subset_group}", quote=FALSE), 
                                                               name),
                                            i=i,
                                            j=j,
                                            ora_res_name=ora_res_name)
          if(interactive()) {
            print(EvalKnitrChunk(chunk_filled))
          } else {
            chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
            cat('\n', chunk_filled, '\n', sep='\n')
          }
        }
        cat(":::\n")
      }
    }
  }
}
```

## Gene Set Enrichment Analysis

Gene Set Enrichment Analysis (GSEA) is a computational method used to determine whether a predefined set of genes shows statistically significant differences in expression between two biological states (e.g., disease vs. control). GSEA evaluates gene sets, which are groups of genes that share common biological functions, chromosomal locations, or regulation.

```{r}
#| label: deg_analysis_run_gsea

if (have_gsea) {
  # Custom genesets for gene-set enrichment analysis
  gsea_geneset_files = param("geneset_files")
  
  # Get genesets to test from MSigDB or user input file
  gsea_term2gene_db = DegsGetGenesets(msigdb_species=param("msigdb_species") %||% param("species"), 
                                      is_msigdb_species_name = !is.null(param("msigdb_species")),
                                      geneset_files=gsea_geneset_files)

  # Run geneset enrichment analysis
  gsea_results_list = purrr::map_depth(contrasts_list[run_gsea], .depth=2, function(contrast) {
    # Run GSEA and add to list
    gsea_result = DegsRunGseaTest(
      contrast=contrast,
      term2gene_db=gsea_term2gene_db, 
      genesets=contrast[["gsea_genesets"]] %||% param("genesets")
    )
    return(gsea_result)
  })
  
  # Write tables to files
  for (gsea_results in gsea_results_list) {
    name = gsea_results[[1]][["name"]]
    
    # Get GSEA results for each comparison
    gsea_tables = purrr::map(gsea_results, function(gsea_result) {
      # if multiple gene sets were analysed, join the result tables
      gsea_table = purrr::map_dfr(names(gsea_result[["results"]]), function(set_name) {
        gsea_res =  gsea_result[["results"]][[set_name]]
        gsea_tbl = gsea_res %>% 
          as.data.frame() %>%
          dplyr::mutate(GeneSet=set_name, .before=1)
        return(gsea_tbl)
      })
      return(gsea_table)
    })
    
    # Collect configuration
    gsea_configuration_table = ContrastConfigurationTable(gsea_results[[1]], 
                                                         config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "downsample_n", "covariate", "design", "gsea_genesets"))
    if ("subset_column" %in% names(gsea_results[[1]])) {
        subset_group = purrr::map_chr(gsea_results, function(gsea_result) return(paste(gsea_result$subset_group, collapse="+"))) %>%
         paste(collapse=",")
        gsea_configuration_table[gsea_configuration_table$Config == "subset_groups", "Value"] = subset_group
    }
    
    # Write to Excel file
    outfile = paste0("gsea_", name, ".xlsx")
    DegsWriteGseaToFile(gsea_tables,
                       file=file.path(module_dir, "results", outfile),
                       parameter=gsea_configuration_table)
    
    # Make top n GSEA plots
    outfile = paste0("gsea_", name, "_plots.pdf")
    pdf(width = 8, height = 5, file.path(module_dir, "results", outfile))
    for (i in seq_along(gsea_results)) {
      gsea_result = gsea_results[[i]]
      
      # Add a small dummy message with the name of the subset as plot (if there is one)
      if ("subset_column" %in% names(gsea_result)) {
        subset_column = gsea_result$subset_column
        subset_group = paste(gsea_result$subset_group, collapse="+")
        p = ggplot() + 
          annotate("text", x = 4, y = 25, size=12, fontface="bold", label = FormatString("Subset {subset_column}: {subset_group}", quote=FALSE)) + 
          theme_void()
        print(p)
      }

      # Generate plots for the top n terms of each GSEA analysis
      for (j in seq_along(gsea_result[["results"]])) {
        gsea_res = gsea_result[["results"]][[j]]
        gsea_res_name = names(gsea_result[["results"]])[[j]]
        top_n = param("gsea_num_plots") %||% 5
        
        # Now get top n terms
        topn_terms = gsea_res %>% 
          as.data.frame() %>% 
          dplyr::slice_max(order_by=abs(NES), n=param("gsea_num_plots") %||% 5) %>%
          dplyr::pull(ID)
        
        # Add a small dummy message with the name of the GSEA analysis and whether significant terms were found
        if (length(topn_terms) > 0) {
          p = ggplot() + 
            annotate("text", x = 4, y = 25, size=8, label = FormatString("Top {top_n} significant terms for geneset {gsea_res_name}", quote=FALSE)) + 
            theme_void()
        } else {
          p = ggplot() + 
            annotate("text", x = 4, y = 25, size=8, label = FormatString("No terms significant for geneset {gsea_res_name}", quote=FALSE)) + 
            theme_void()
        }
        print(p)
        
        # Do GSEA plots (save in one combined pdf file)
        for(id in topn_terms) {
          print(enrichplot::gseaplot2(gsea_res, id, title=id, base_size=11))
        }
      }
    }
    dev.off()
  }
} else {
    CalloutBox("No GSEA requested.", type="note")
}
```

```{r}
#| label: tbl-deg_analysis_gsea_summary
#| tbl-cap: "Summary of the GSEA tests"
#| eval: !expr have_gsea
#| include: !expr have_gsea

if (have_gsea) {
  # Create a summary table of all GSEA tests
  gsea_summary_table = purrr::map_depth(gsea_results_list, .depth=2, function(gsea_result) {
    # Collect summary for each analysis result of a GSEA test (for each geneset)
    summary_table = purrr::map_dfr(gsea_result[["results"]], function(gsea_res) {
      # Get comparison name, condition column and values, subset column and subset group. . If multiple, join by '+'.
      sum_tbl = data.frame(Comparison=gsea_result[["name"]],
               Condition=gsea_result[["condition_column"]], 
               Group1=paste(gsea_result[["condition1"]], collapse="+"), 
               Group2=paste(gsea_result[["condition2"]], collapse="+"))
      if ("subset_column" %in% names(gsea_result)) {
        sum_tbl$Subset = gsea_result[["subset_column"]]
        sum_tbl$SubsetGroup = paste(gsea_result[["subset_group"]], collapse="+")
      } else {
        sum_tbl$Subset = ""
        sum_tbl$SubsetGroup = ""
      }
      
      # Get the number of geneset terms that were tested, are significant and have an enrichment towards one or the other condition for each GSEA analysis
      genesets = gsea_res@geneSets
      genesets_lengths = purrr::map_int(genesets, length)
      sum_tbl$Terms = length(genesets)
      sum_tbl$TermsTested = sum(genesets_lengths >= 10 & genesets_lengths<=500)
      sum_tbl$Sign = nrow(gsea_res)
      sum_tbl$Sign_up = sum(gsea_res$NES>0)
      sum_tbl$Sign_down = sum(gsea_res$NES<0)
      
      return(sum_tbl)
    })
    summary_table = dplyr::mutate(summary_table, GeneSet=names(gsea_result[["results"]]), .before=Terms)
    
    return(summary_table)
  })  %>% 
      purrr::flatten() %>% 
      dplyr::bind_rows()
  
  gt(gsea_summary_table) %>%
      sub_missing(columns=1:ncol(gsea_summary_table), missing_text="")
}
```

```{r}
#| label: deg_analysis_gsea_results
#| results: asis
#| eval: !expr have_gsea
#| include: !expr have_gsea

# Generate report sections for each GSEA comparison
if (have_gsea) {
  # Iterate over the comparisons
  for (gsea_results in gsea_results_list) {
    # gsea_results: Result list for this comparison
    
    # Print name in header
    name = gsea_results[[1]]$name
    cat(FormatString("### {name}\n\n", quote=FALSE))
    
    # Collect configuration
    gsea_configuration_table = ContrastConfigurationTable(gsea_results[[1]], 
                                                         config_names = c("condition_column", "condition1", "condition2", "subset_column", "subset_groups", "bulk_by", "pseudobulk_samples", "assay", "layer", "test", "padj", "downsample_n", "covariate", "design", "gsea_genesets"))
    if ("subset_column" %in% names(gsea_results[[1]])) {
        subset_group = purrr::map_chr(gsea_results, function(gsea_result) return(paste(gsea_result$subset_group, collapse="+"))) %>%
         paste(collapse=",")
        gsea_configuration_table[gsea_configuration_table$Config == "subset_groups", "Value"] = subset_group
    }
    gsea_configuration_table = dplyr::filter(gsea_configuration_table, Value != "-")
    
    # Configuration chunk template
    chunk_template_gsea_configuration = "
\`\`\`{r}
#| label: tbl-deg_analysis_gsea_configuration_{{name}}
#| tbl-cap: 'Configuration for GSEA comparison {{name}}'

gt(gsea_configuration_table)
\`\`\`
"
    # Then fill out the configuration chunk template and render/knit
    chunk_filled =  knitr::knit_expand(text=chunk_template_gsea_configuration, 
                                         name=name)
    if(interactive()) {
      print(EvalKnitrChunk(chunk_filled))
    } else {
      chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
      cat(chunk_filled, '\n', sep='\n')
    }
      
    # Now show the result(s) for this comparison. If multiple subsets were analysed, there will be multiple results.
    # Note: Since there can be multiple results, we include i as a counter to make them unique.
    for (i in seq_along(gsea_results)) {
      # gsea_result: Result list for this comparison and subset
      gsea_result = gsea_results[[i]]
      name = gsea_result$name
      
      # Add a header if there are multiple subsets
      if ("subset_column" %in% names(gsea_result)) {
        subset_column = gsea_result$subset_column
        subset_group = paste(gsea_result$subset_group, collapse="+")
        cat(FormatString("#### {i}. {subset_column} - {subset_group}", quote=FALSE), '\n\n')
      } else {
        subset_column = ""
        subset_group = ""
      }
      
      # Chunk template for the GSEA summary (per comparison and subset)
      chunk_template_gsea_summary = "
\`\`\`{r}
#| label: tbl-deg_analysis_gsea_summary_{{name}}_{{i}}
#| tbl-cap: 'GSEA results for {{name_subset}}'

# Plot summary of tested and significant terms for all GSEA analyses
gsea_results_table = gsea_summary_table %>% 
    dplyr::filter(Comparison == '{{name}}', SubsetGroup=='{{subset_group}}')
    
gt(gsea_results_table) %>%
    sub_missing(columns=1:ncol(gsea_results_table), missing_text='')
\`\`\`
"
      
      # Print a summary of all GSEA analyses
      chunk_filled = knitr::knit_expand(text=chunk_template_gsea_summary,
                                        name=name,
                                        name_subset=ifelse(nchar(subset_group)>0, 
                                                           FormatString("{name}, {subset_column}: {subset_group}", quote=FALSE),
                                                           name),
                                        i=i,
                                        subset_group=subset_group)
      if(interactive()) {
        print(EvalKnitrChunk(chunk_filled))
      } else {
        chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
        cat('\n', chunk_filled, '\n', sep='\n')
      }
      
      # Iterate over all GSEA analyses
      cat("::: {.panel-tabset}\n")
      for (j in seq_along(gsea_result[["results"]])) {
        # gsea_res: GSEA analysis for one geneset
        gsea_res = gsea_result[["results"]][[j]]
        
        # Header
        cat("#####", j, "\n\n")
        
        # Chunk template for the GSEA plot (per comparison, subset and geneset)
        # - top 10 terms as table
        # - top 10 terms as plot
chunk_template_gsea_results = "
\`\`\`{r}
#| label: fig-deg_analysis_gsea_plots_{{name}}_{{i}}_{{j}}
#| fig-cap: 'Top 10 terms of {{gsea_res_name}} for {{name_subset}}'

# Plot the top 10 terms
enrichplot::ridgeplot(gsea_res, showCategory=10, orderBy='NES', label_format=40) +
                  AddPlotStyle(legend_position='bottom', legend_title='Adj. p-value') +
                  viridis::scale_fill_viridis(direction = -1, 
                                              breaks = function(x) return(c(min(x), max(x))), 
                                              labels=scales::scientific)
\`\`\`
"
        
        # Fill in chunk for GSEA analysis and render
        chunk_filled = knitr::knit_expand(text=chunk_template_gsea_results,
                                          name=name,
                                          name_subset=ifelse(nchar(subset_group)>0, 
                                                             FormatString("{name}, {subset_column}: {subset_group}", quote=FALSE),
                                                             name),
                                          i=i,
                                          j=j,
                                          gsea_res_name=names(gsea_result[["results"]])[j])
        if(interactive()) {
          print(EvalKnitrChunk(chunk_filled))
        } else {
          chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
          cat('\n', chunk_filled, '\n', sep='\n')
        }
      }
      cat(":::\n")
    }
  }
}
```

## Output

```{r}
#| label: deg_analysis_export_contrast
#| eval: !expr have_export_contrasts

have_export_contrasts = TRUE

if (have_export_contrasts) {
  # Export the contrast information as tables so that it can be used by other tools
  for(contrasts in contrasts_list[export_contrasts]) {
    # Name of the comparison
    name = contrasts[[1]][["name"]]

    # Is it bulked data
    bulked_data = "bulk_by" %in% names(contrasts[[1]]) | "pseudobulk_samples" %in% names(contrasts[[1]])
    
    # What kind of data is it - counts data, reduction or barcode metadata
    data_type = contrasts[[1]][["data_type"]]
    
    # Decide what to export
    if (data_type == "feature_data") {
      assay = contrasts[[1]][["assay"]]
      layer = ifelse(bulked_data, "counts", contrasts[[1]][["layer"]])
    } else if (data_type == "reduction") {
      assay = "reduction"
      layer = "counts"
    } else if (data_type == "barcode_metadata") {
      assay = "barcode_metadata"
      layer = "counts"
    }
    
    # Now process each subset for this comparison
    for (i in seq_along(contrasts)) {
      contrast = contrasts[[i]]
      
      # Get data to export
      data_to_export = SeuratObject::GetAssayData(contrast[["sc_subset"]], assay=assay, layer=layer)
      barcode_metadata_to_export = contrast[["sc_subset"]][[]] %>%
        as.data.frame() %>%
        tibble::rownames_to_column(var="barcode")
      feature_metadata_to_export = contrast[["sc_subset"]][[assay]][[]] %>%
        as.data.frame() %>%
        dplyr::select(feature_id, feature_name, feature_type)

      # For bulked counts data, reductions and barcode metadata, export as Excel
      if (bulked_data | data_type %in% c("reduction", "barcode_metadata")) {
        data_to_export = data_to_export %>% 
          as.data.frame() %>%
          tibble::rownames_to_column(var="Feature")
        data_to_export = list(barcode_metadata=barcode_metadata_to_export, 
                              feature_metadata=feature_metadata_to_export, 
                              counts=data_to_export)
        
        # Output to Excel file
        output_file = FormatString("contrast_data_{name}_{i}.xlsx", quote=FALSE)
        openxlsx::write.xlsx(data_to_export, file=file.path(module_dir, "results", output_file))
      } else {
        # For non-bulked data, output in matrix market format (with matrix.mtx, features.tsv.gz, barcodes.tsv.gz)
        
        # Output to directory
        output_directory = FormatString("contrast_data_{name}_{i}", quote=FALSE)
        WriteCounts_MatrixMarket(counts=data_to_export, 
                                 path=file.path(module_dir, "results", output_directory),
                                 overwrite=TRUE,
                                 barcode_data=barcode_metadata_to_export,
                                 feature_data=feature_metadata_to_export)
      }
    }
  }
}
```

## Software

```{r}
#| label: deg_analysis_save_software

sessioninfo = ScrnaseqSessionInfo(getwd()) %>% as.data.frame()
gt(sessioninfo)
```

## Parameter

```{r}
#| label: deg_analysis_save_parameter  

paraminfo = ScrnaseqParamsInfo(param()) %>% as.data.frame()
gt(paraminfo)
```

```{r}
#| label: deg_analysis_save_seurat

# Save Seurat object and layer data
outdir = file.path(module_dir, "sc")
with_progress({
  SaveSeuratRdsWrapper(sc,
                       outdir=outdir,
                       write_disk_data=FALSE,
                       relative_paths=FALSE,
                       compress=FALSE
                       )
}, enable=verbose)
```

```{r}
#| label: deg_analysis_finish

# Stop multisession workers
plan(sequential)
```

