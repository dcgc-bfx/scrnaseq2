---
# Module-specific parameters (that are not already in the profile yaml)
# Defaults
params:
  # Name of the module used in configurations
  module: "deg_analysis"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/10_deg_analysis"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  # NOTE: Change to null if all modules are implemented and sc objects are written
  prev_module_dir: null
  
  # Default assay
  default_assay: null

  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. 
  # Computations will access only the relevant parts of the data. 
  # Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: false
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. 
  # This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). 
  # Once done, matrix directories will be copied back to the module directory. 
  # The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: false
  
  # Number of cores to use for computations
  cores: 4
  
  # Contrasts to find differentially expressed genes
  # Add entries below 'value'.
  # Each entry has a unique name and the following keys:
  #
  #  condition_column: Categorial column in the barcode metadata (required)
  #  condition_group1: Condition levels in group 1 (required)
  #                    Use 'level1+level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #  condition_group2: Condition levels in group 2 (required)
  #                    Use 'level1,level2' to use multiple levels
  #                    Use '!level1' or '!level1+level2 to use all but these levels (i.e. negate)
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #
  # subset_column: Categorial column in the barcode metadata to subset for tests (default: null)
  #                For example, use 'orig.ident' for sample and 'seurat_clusters' for cluster (default: null)
  # subset_group: Levels to subset
  #               Use 'level1+level2' to use multiple levels for one subset
  #               Use 'level1+level2,level3' to do multiple subsets for testing
  #                    Can also be a Excel/csv file with barcodes with 'barcode' or 'sample:original_barcode' per line. 
  #                    Original barcode refers to the one used in the dataset.
  #
  # bulk_by: Generate bulk samples by aggregating barcodes by one or more columns (e.g. 'individual' or 'individual+genotype') (default: null). Control the number of barcodes per bulk sample with downsample_n.
  # pseudobulk_samples: Generate this number of pseudo-bulk samples (default: null). Control the number of barcodes per pseudo-bulk sample with downsample_n.
  #
  # assay: Seurat assay, dimensionality reduction or barcode metadata columns ('column1,column2') to test on (default: 'RNA')
  # layer: In case of Seurat assay, which layer/slot to use (default: 'data'). Should be set specific for the test.
  # padj: Maximum adjusted p-value (default: 0.05)
  # log2FC: Minimum absolute log2 fold change (default: 0)
  # min_pct: Minimum percentage of barcodes expressing a feature in one group (default: 0.05)
  # test: Type of test. Can be 'wilcox', 'bimod', 'roc', 't', 'negbinom', 'poisson', 'LR', 'MAST', 'DESeq2' (default: 'wilcox').
  # downsample_barcodes: Downsample each group to at most n barcodes (default: null)
  # covariate: One or two columns (comma-separated) to include as covariates (default: null)
  #
  contrasts:
      value:
          - Comparison1:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
          - Comparison2:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
                bulk_by: "seurat_clusters"
          - Comparison3:
                condition_column: "orig.ident"
                condition_group1: "pbmc_1k"
                condition_group2: "pbmc_5k"
                subset_column: "seurat_clusters"
                subset_group: "1,2,3+4"
    
  # Excel or csv file with contrasts
  contrasts_file: null
  
  # Run DEG tests: True, false or a list with contrast names
  run_deg_tests:
      - Comparison1
      - Comparison3
  
  # Run over-representation analysis (ORA) for DEG results: True, false or a list with contrast names
  run_deg_ora: true
  
  # Run gene set enrichment analysis (GSEA): True, false or a list with contrast names
  run_gsea: true
    
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# DEG Analysis

```{r}
#| label: setup

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "scrnaseq")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)
library(patchwork)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir
```

```{r}
#| label: deg_analysis_preparation

# CODE
# Working directory is automatically back to scrnaseq2 at this point
# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")
source("R/functions_degs.R")

# Be verbose or not
verbose = param("verbose")

# Parallelisation plan for all functions that support future
plan(multisession, workers=param("cores"))

# DIRECTORIES
# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# SEURAT OBJECT
# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatString("Could not find a sc.rds file in {prev_module_dir}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
} else {
  on_disk_path = file.path(module_dir, "sc")
}

# Set default assay standard
default_assay = param("default_assay")
if (is.null(default_assay)) default_assay = Seurat::DefaultAssay(sc)
Seurat::DefaultAssay(sc) = default_assay

# Parse the contrasts information
if (is.character(param("constrasts")) && file.exists(param("contrasts"))) {
  # Read from file
  contrasts_file = param("contrasts")
  
  # Sheet number appended?
  sheet = 1
  if (grepl(":\\d+$", deg_contrasts_file)) {
    sheet = gsub(pattern=".+:(\\d+)$", replacement="\\1", x=contrasts_file)
    contrasts_file = gsub(pattern=":\\d+$", replacement="", x=contrasts_file)
  }
  
  # Read Excel file and split into list, remove NA entries
  contrasts_list = readxl::read_excel(contrasts_file, sheet=1, col_names=TRUE)
  contrasts_list = split(contrasts_list, seq(nrow(contrasts)))
  
  contrasts_list = purrr::map(contrasts_list, function(contrast) {
      is_na = is.na(contrast)
      if (sum(is_na) > 0) contrast[[is_na]] = NULL
      return(contrast)
  })

} else {
  contrasts_list = param("contrasts")
    
  # Read from yaml parameter and prepare list
  contrasts_list = purrr::map(seq(contrasts_list), function(i) {
      contrast = contrasts_list[[i]][[1]]
      contrast$name = names(contrasts_list[[i]])
      return(contrast)
  })
}

# Set up a contrasts list. Check if there is enough information for each contrast and if contrasts are valid. 
contrasts_list = NewContrastsList(sc, contrasts_list)

# Prepare (subset) Seurat objects for each contrast. Bulk-aggregate if requested. Downsample if requested.
contrasts_list = PrepareContrastsListObjects(sc, contrasts_list)

# Which contrasts should be DEG tested?
run_deg_tests = param("run_deg_tests")
if (is.logical(run_deg_tests) && run_deg_tests) {
  deg_tests_idx = seq(contrasts_list)
} else if (is.logical(run_deg_tests) && !run_deg_tests) {
  deg_tests_idx = c()
} else if (is.character(run_deg_tests)) {
  deg_tests_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_deg_tests))
}

# For the contrasts that are DEG tested: for which should also over-representation analysis be run?
run_deg_ora = param("run_deg_ora")
if (is.logical(run_deg_ora) && run_deg_ora) {
  deg_ora_idx = seq(contrasts_list)
} else if (is.logical(run_deg_ora) && !run_deg_ora) {
  deg_ora_idx = c()
} else if (is.character(run_deg_ora)) {
  deg_ora_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_deg_ora))
}
if (!all(deg_ora_idx %in% deg_tests_idx)) {
  stop("Not all contrasts for over-representation analysis are also tested for DEGs.")
}

# Which contrasts should be analysed with GSEA?
run_gsea = param("run_gsea")
if (is.logical(run_gsea) && run_gsea) {
  gsea_idx = seq(contrasts_list)
} else if (is.logical(run_gsea) && !run_gsea) {
  gsea_idx = c()
} else if (is.character(run_gsea)) {
  gsea_idx = seq(contrasts_list) %>% 
      purrr::keep(function(i) return(contrasts_list[[i]]$name %in% run_gsea))
}

```

## DEG Analysis

```{r}
#| label: deg_analysis_compute_degs

if (length(deg_tests_idx) > 0) {
  # Run DEG tests (sequential for now)
  deg_results_list = RunDEGTests(contrasts_list[deg_tests_idx])
}

```

## Software

```{r}
#| label: deg_analysis_save_software

sessioninfo = ScrnaseqSessionInfo(getwd()) %>% as.data.frame()
gt(sessioninfo)
```

## Parameter

```{r}
#| label: deg_analysis_save_parameter  

paraminfo = ScrnaseqParamsInfo(param()) %>% as.data.frame()
gt(paraminfo)
```

```{r}
#| label: deg_analysis_save_seurat

# This will overwrite the (bugged) function SeuratObject::SaveSeuratRds with the content of our function SaveSeuratRds_Fixed
assignInNamespace("SaveSeuratRds",SaveSeuratRds_Fixed, ns="SeuratObject")

# Save Seurat object and layer data
with_progress({
  SaveSeuratRdsWrapper(sc,
                       on_disk_layers=on_disk_counts,
                       outdir=file.path(module_dir, "sc"))
}, enable=verbose)
```

```{r}
#| label: deg_analysis_finish

# Stop multisession workers
plan(sequential)
```

