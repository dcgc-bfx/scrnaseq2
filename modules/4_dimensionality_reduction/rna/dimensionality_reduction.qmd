---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "dimensionality_reduction_rna"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/4_dimensionality_reduction/rna"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay.
  default_assay: "RNA"
  
  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. Computations will access only the relevant parts of the data. Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: true
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). Once done, matrix directories will be copied back to the module directory. The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: true
  
  # Which normalization should be used for analysis?
  # lognorm (Seurat), scran or sct
  normalisation_method: "lognorm"
  
  # Number of variable features to use
  num_variable_features: 3000
  
  # Which dimensionality reduction to use: pca
  dimensionality_reduction_method: "pca"
  
  # Number of dimensions to compute
  num_dimensions_compute: 50
  
  # Number of dimensions to use
  num_dimensions_use: 10
  
  # Use sketch-based integration methods for analysis
  use_sketching: true
  
  # One or more integration method(s) to use. 
  # The following methods are available: null (just merge), CCAIntegration, RPCAIntegration, HarmonyIntegration, FastMNNIntegration, scVIIntegration.
  integration_methods:
  - "CCAIntegration"
  - "RPCAIntegration"
  - "HarmonyIntegration"
  - "FastMNNIntegration"

  # Parameters for CCAIntegration
  CCAIntegration: null
  
  # Parameters for RPCAIntegration
  RPCAIntegration: null
  
  # Parameters for HarmonyIntegration
  HarmonyIntegration: null
  
  # Parameters for FastMNNIntegration
  FastMNNIntegration: null
  
  # Parameters for scVIIntegration.
  scVIIntegration: null
    
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: "auto"
---

# Dimensionality reduction

```{r}
#| label: setup
#| message: false
#| warning: false

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "default")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(SeuratWrappers)
library(ggplot2)
library(future)
library(patchwork)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir

# Parallisation plan for all functions that support future
plan(multisession, workers=4, gc=TRUE)
```

```{r}
#| label: dimensionality_reduction_rna_preparation

########
# Code #
########

# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")

# Be verbose
verbose=param("verbose")

###############
# Directories #
###############

# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

#################
# Seurat object #
#################

# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatMessage("Could not find a sc.rds file in {{prev_module_dir}}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
} else {
  on_disk_path = file.path(module_dir, "sc")
}

# Set default assay standard
default_assay = param("default_assay")
normalisation_method = param("normalisation_method")
use_sketching = param("use_sketching")
default_assay = ifelse(normalisation_method=="SCT", 
                       paste(default_assay, "SCT", sep="_"), 
                       default_assay)

# If sketching should be used, check for the sketch assay and then set as default
if (use_sketching) {
  sketched_assay_name = paste(default_assay, "sketch", sep=".")
  if (!sketched_assay_name %in% SeuratObject::Assays(sc)) {
    stop(FormatMessage("The option 'use_sketching' is set to true but the sketch assay {sketched_assay_name} was not found. It should be created in one of the previous modules."))
  }
  SeuratObject::DefaultAssay(sc) = sketched_assay_name
}
```

A single-cell dataset of 20,000 genes and 5,000 cells has 20,000 dimensions. At this point of the analysis, we have already reduced the dimensionality of the dataset to 3,000 variable genes. The biological manifold however can be described by far fewer dimensions than the number of (variable) genes, since expression profiles of different genes are correlated if they are involved in the same biological process. Dimension reduction methods aim to find these dimensions. There are two general purposes for dimension reduction methods: to __summarize__ a dataset, and to __visualize__ a dataset. 

## PCA

We use Principal Component Analysis (PCA) to __summarize__ a dataset, overcoming noise and reducing the data to its essential components. Later, we use Uniform Manifold Approximation and Projection (UMAP) to __visualize__ the dataset, placing similar cells together in 2D space, see below. 

<details class="details_box">
  <summary class="details_summary">PCA in a nutshell</summary>

Principal Component Analysis is a way to summarize a dataset and to reduce noise by averaging similar gene expression profiles. The information for correlated genes is compressed into single dimensions called principal components (PCs) and the analysis identifies those dimensions that capture the largest amount of variation. This process gives a more precise representation of the patterns inherent to complex and large datasets.

In a PCA, the first PC captures the greatest variance across the whole dataset. The next PC captures the greatest remaining amount of variance, and so on. This way, the top PCs are likely to represent the biological signal where multiple genes are affected by the same biological processes in a coordinated way. In contrast, random technical or biological noise that affects each gene independently are contained in later PCs. Downstream analyses can be restricted to the top PCs to focus on the most relevant biological signal and to reduce noise and unnecessary computational overhead. 
</details>

To decide how many PCs to include in downstream analyses, we visualize the cells and genes that define the PCA.

```{r}
#| label: dimensionality_reduction_rna_run

dimensionality_reduction_method = param("dimensionality_reduction_method")
num_dimensions_compute = param("num_dimensions_compute")

# Run dimensionality reduction
sc = Seurat::RunPCA(sc, 
                    verbose=verbose, 
                    npcs=min(num_dimensions_compute, ncol(sc)),
                    seed.use=getOption("random_seed"))

# If sketching was used, project PCA of sketch to full dataset

```

```{r}
#| label: dimensionality_reduction_rna_loadings
#| fig-cap: "Loadings of the dimensionality reduction"
#| fig-height: 4

# Plot loadings for first and second dimension
plist = Seurat::VizDimLoadings(sc, reduction=dimensionality_reduction_method, dims=1:2, combine=FALSE, balanced=TRUE)
for (i in seq(plist)) {
  plist[[i]] = plist[[i]] + 
    AddPlotStyle()
}

print(plist[[1]] + plist[[2]])
```

```{r}
#| label: dimensionality_reduction_rna_dim_dimensions
#| fig-cap: "Cells arranged by the first two dimensions"

# Plot cells for the first two dimensions
p = Seurat::DimPlot(sc, reduction=dimensionality_reduction_method, cols=ScColours(sc, "orig.ident")) +
  AddPlotStyle()
print(p)
```

```{r}
#| label: dimensionality_reduction_rna_loadings_heatmaps
#| fig-cap: "Top gene loadings of the first dimensions"
#| fig-subcap: ""
#| layout-ncol: 3
#| fig-height: 3
#| fig-width: 2.6

# Plot loading for the top 20 dimensions
plist = Seurat::DimHeatmap(sc, 
                           reduction=dimensionality_reduction_method,
                           dims=1:min(20, ncol(sc)), 
                           cells=min(500, ncol(sc)),
                           balanced=TRUE, 
                           fast=FALSE, 
                           combine=FALSE)

for (i in seq(plist)) {
  plist[[i]] = plist[[i]] +
    AddPlotStyle(base_font_size=9, title=paste("Dim", i)) +
    theme(legend.position="none") +
    viridis::scale_fill_viridis() +
    theme(axis.text.x=element_blank(),
          axis.ticks=element_blank())

  print(plist[[i]])
}
```

## Dimensionality of the dataset

We next need to decide how many PCs we want to use for our analyses. PCs include biological signal as well as noise, and we need to determine the number of PCs with which we include as much biological signal as possible and as little noise as possible. The following "Elbow plot" is designed to help us make an informed decision. It shows PCs ranked based on the percentage of variance they explain.

<details class="details_box">
  <summary class="details_box">How do we determine the number of PCs for downstream analysis?</summary>

The top PC captures the greatest variance across cells and each subsequent PC represents decreasing levels of variance. By visual inspection of the Elbow plot, we try to find the point at which we can explain most of the variance across cells. Commonly, the top 10 PCs are chosen. It may be helpful to repeat downstream analyses with a different number of PCs, although the results often do not differ dramatically. Note that it is recommended to rather choose too many than too few PCs. 
</details>

```{r}
#| label: dimensionality_reduction_rna_elbow_plot
#| fig-cap: "Variance explained by computed dimensions"

num_dimensions_use = param("num_dimensions_use")

# Plot the variance explained for the computed components
p = Seurat::ElbowPlot(sc, reduction=dimensionality_reduction_method, ndims=min(50, ncol(sc))) + 
  geom_vline(xintercept=num_dimensions_use + .5, col="firebrick", lty=2) + 
  AddPlotStyle() 
print(p)
```

For the current dataset, `r num_dimensions_use` PCs were chosen.

## Integration

```{r}
#| label: integration_rna_run_integration

integration_methods = param("integration_methods")
min_barcodes_for_sketching = param("min_barcodes_for_sketching")
num_barcodes_for_sketching = param("num_barcodes_for_sketching")
integration_methods_params = purrr::map(integration_methods, function(method) {
  par_lst = param(method)
  
  # Parse into argument name and value. Interpret values (still strings) as R code.
  if (!is.null(par_lst)) {
    par_lst = stringr::str_split(par_lst, pattern="=", n=2)
    nms = purrr::map(par_lst, 1)
    vls = purrr::map(par_lst, 2)
    vls = purrr::map(vls, function(v) return(eval(parse(text=v))))
    par_lst = setNames(vls, nms)
  }
  return(par_lst)
})
names(integration_methods_params) = integration_methods

normalisation_method = param("normalisation_method")
feature_selection_method = param("feature_selection_method")
num_variable_features = param("num_variable_features")
num_datasets = length(SeuratObject::Layers(sc, assay=default_assay, search="^counts"))
num_barcodes = length(SeuratObject::Cells(sc[[default_assay]]))
use_sketching = num_barcodes > min_barcodes_for_sketching

if (length(integration_methods) > 0 & num_datasets > 0) {
  # Integration requested and necessary
  
  # This will overwrite the (bugged) function Seurat::RPCAIntegration with the content of our function RPCAIntegration_Fixed
  assignInNamespace("RPCAIntegration",RPCAIntegration_Fixed, ns="Seurat")
  # This will overwrite the (bugged) function Seurat::scVIIntegration with the content of our function scVIIntegration_Fixed
  assignInNamespace("scVIIntegration",scVIIntegration_Fixed, ns="SeuratWrappers")
  
  # Integrate
  for(method in integration_methods) {
    # New reduction name
    new_reduct = dplyr::case_match(method,
                                   "CCAIntegration" ~ "cca",
                                   "RPCAIntegration" ~ "rpca",
                                   "HarmonyIntegration" ~ "harmony",
                                   "FastMNNIntegration" ~ "mnn",
                                   "scVIIntegration" ~ "scvii")
    new_reduct = paste("integrated", new_reduct, sep=".")
    
    # Additional method-specific arguments passed by config
    additional_args = integration_methods_params[[method]]
    
    # Call wrapper
    sc = IntegrateLayersWrapper(sc=sc,
                                integration_method=method,
                                orig_reduct=dimensionality_reduction_method,
                                new_reduct=new_reduct,
                                additional_args=additional_args,
                                verbose=verbose)
    
    # If sketching was used, project integrated dimensionality reduction of sketch to full dataset
    if (use_sketching) {
      sc = Seurat::ProjectIntegration(sc,
                                      sketched.assay=SeuratObject::DefaultAssay(sc), 
                                      assay=default_assay,
                                      reduction=new_reduct,
                                      reduction.name=paste(new_reduct, "full", sep="."),
                                      reduction.key=paste0(new_reduct, "full", "_") %>% 
                                        gsub(pattern="\\.", replacement="", x=.) %>%
                                        tolower(),
                                      seed=getOption("random_seed"),
                                      verbose=verbose)
    }
  }
  
  # Reset default assay if sketching was used
  if (use_sketching) {
    SeuratObject::DefaultAssay(sc) = default_assay
  }
  
  # Join layers
  sc = SeuratObject::JoinLayers(sc)
  
  # Message
  glue::glue("\n::: {{.callout-note}}\nSamples are integrated.\n:::\n") %>% 
    knitr::asis_output()
  
} else if (length(integration_methods) == 0 & num_datasets > 1) {
  # Join layers
  sc = SeuratObject::JoinLayers(sc)
  
# Integration not requested (just merge)
  glue::glue("\n::: {{.callout-note}}\nSamples are merged. No integration needed!\n:::\n") %>% 
    knitr::asis_output()
  
} else if (num_datasets == 1) {
  # Integration not necessary
  glue::glue("\n::: {{.callout-note}}\nOnly one sample. No integration needed!\n:::\n") %>% 
    knitr::asis_output()
}
```

## Save Seurat object

```{r}
#| label: integration_rna_save_seurat

# This will overwrite the (bugged) function SeuratObject::SaveSeuratRds with the content of our function SaveSeuratRds_Fixed
assignInNamespace("SaveSeuratRds",SaveSeuratRds_Fixed, ns="SeuratObject")

# Save Seurat object and layer data
with_progress({
  SaveSeuratRds_Custom(sc,
              outdir=file.path(module_dir, "sc"),
              on_disk_layers=on_disk_counts)
}, enable=verbose)

```

```{r}
#| label: integration_rna_finish

# Stop multisession workers
plan(sequential)
```
