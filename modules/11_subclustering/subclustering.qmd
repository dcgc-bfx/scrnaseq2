---
# Module-specific parameters (that are not already in the profile yaml)
# Defaults
params:
  # Name of the module used in configurations
  module: "subclustering"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/11_subclustering"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  # NOTE: Change to null if all modules are implemented and sc objects are written
  prev_module_dir: null
  
  # Default assay
  default_assay: null
    
  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. 
  # Computations will access only the relevant parts of the data. 
  # Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: true
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. 
  # This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). 
  # Once done, matrix directories will be copied back to the module directory. 
  # The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: true
  
  # Number of cores to use for computations
  cores: 4
  
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# Subclustering

```{r}
#| label: setup

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "scrnaseq")}

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)
library(patchwork)

# Get module directory (needed to access files within the module directory)
module_dir = params$module_dir
```

```{r}
#| label: subclustering_preparation

# CODE
# Working directory is automatically back to scrnaseq2 at this point
# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")

# Be verbose or not
verbose = param("verbose")

# Parallelisation plan for all functions that support future
plan(multisession, workers=param("cores"))

# DIRECTORIES
# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# SEURAT OBJECT
# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatString("Could not find a sc.rds file in {prev_module_dir}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Set default assay standard
default_assay = param("default_assay")
if (is.null(default_assay)) default_assay = Seurat::DefaultAssay(sc)
Seurat::DefaultAssay(sc) = default_assay

# ON-DISK LAYERS (if used)
on_disk_counts = param("on_disk_counts")

# If requested, move on-disk layers to faster temp location for faster access
#on_disk_use_tmp = param("on_disk_use_tmp")

# Note: counts data is not used in this module, therefore deactivated
on_disk_use_tmp = FALSE
if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
}

# Variable to indicate if barcodes were removed from the analysis
# In this case, when using on-disk matrices, they need to be written to disk again
barcodes_removed = FALSE
```

<!-- 
## Remove cells

USER_INPUT: Add explanation here

```{r}
#| label: subclustering_remove_barcodes_1
#| results: asis

# Use this chunk to remove barcodes from the analysis.
# However note that it might be better to remove this barcode already in the QC module.

# Get barcode metadata for assay
bcs = SeuratObject::Cells(sc[[default_assay]])
barcode_metadata = sc[[]][bcs, ]

# USER INPUT: 
# - Specify what barcodes to remove here
# - barcodes_to_remove should contain the barcodes to remove
barcodes_to_remove = barcode_metadata %>%
  dplyr::filter(seurat_clusters == "1") %>%
  rownames()

# Filter barcodes:
# a) barcodes that are present only in this assay, will be removed from the whole Seurat object
# b) barcodes that are present in other assays, will be removed from this assay only
barcodes_other_assays = purrr::map(setdiff(SeuratObject::Assays(sc), default_assay), function(a) return(SeuratObject::Cells(sc[[a]]))) %>% 
  purrr::flatten_chr()

# Remove from assay barcodes that are still present in other assays
barcodes_to_remove_assay = intersect(barcodes_to_remove, barcodes_other_assays)
barcodes_to_keep = setdiff(SeuratObject::Cells(sc[[default_assay]]), barcodes_to_remove_assay)
sc[[default_assay]] = subset(sc[[default_assay]], cells=barcodes_to_keep)

# Remove from Seurat object barcodes that are not present in other assays
barcodes_to_remove_sc = setdiff(barcodes_to_remove, barcodes_other_assays)
if (length(barcodes_to_remove_assay) > 0) {
  barcodes_sc = purrr::map(SeuratObject::Assays(sc), function(a) return(SeuratObject::Cells(sc[[a]]))) %>% purrr::flatten_chr() %>% unique()
  barcodes_sc = setdiff(barcodes_sc, barcodes_to_remove_sc)
  sc = subset(sc, cells=barcodes_sc)
}

# Indicate that barcodes were removed so that on-disk matrices (if used) are updated
barcodes_removed = TRUE

# Print information
CalloutBox(x=FormatString("Removed {length(barcodes_to_remove)} barcodes from the analysis.", quote=FALSE), type="note")
```

```{r}
#| label: fig-subclustering_remove_barcodes_1
#| fig-cap: 'Clusters after removing barcodes'

# Plot a UMAP
DimPlot(sc, label=TRUE)
```

-->

<!--
## Merge/rename cluster

USER_INPUT: Add explanation here

```{r}
#| label: subclustering_merge_rename_cluster_1
#| results: asis

# Use this chunk to merge or rename clusters in the Seurat object

# Get barcodes for assay
bcs = SeuratObject::Cells(sc[[default_assay]])

# USER_INPUT: 
# - Set/update cluster column and what clusters to merge/rename
# - Always keep the first condition since it ensures that only barcodes of the current assay are affected
# - Keep the last argument as it handles all other cases
sc$subclustering = dplyr::case_when(
  !SeuratObject::Cells(sc) %in% bcs ~ NA,
  
  sc$seurat_clusters %in% c("1", "2", "3") ~ "1-3",
  sc$seurat_clusters %in% c("4", "5", "6") ~ "4-6",
  
  .default = sc$seurat_clusters
)
```

```{r}
#| label: fig-subclustering_merge_rename_cluster_2
#| fig-cap: 'Clusters after merging and/or renaming'

# Plot a UMAP
DimPlot(sc, group.by="subclustering", label=TRUE)
```

-->




## Software

```{r}
#| label: subclustering_save_software

sessioninfo = ScrnaseqSessionInfo(getwd()) %>% as.data.frame()
gt(sessioninfo)
```

## Parameter

```{r}
#| label: read_data_save_parameter  

paraminfo = ScrnaseqParamsInfo(param()) %>% as.data.frame()
gt(paraminfo)
```

```{r}
#| label: clusterqc_save_seurat

# Save Seurat object and layer data
# Note: counts and normalized data have not been changed in this module, no copying needed
outdir = file.path(module_dir, "sc")
with_progress({
  SaveSeuratRdsWrapper(sc,
                       outdir=outdir,
                       write_disk_data=barcodes_removed,
                       relative_paths=FALSE,
                       compress=FALSE
                       )
}, enable=verbose)
```

```{r}
#| label: clusterqc_finish

# Stop multisession workers
plan(sequential)
```
